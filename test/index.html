<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Tags -->
    <title>Typing Defender - Ultimate Edition</title>
    <meta name="description" content="Play Typing Defender, a visually stunning 3D typing shooter game.">
    <meta name="author" content="Anil Lama">

    <!-- Firebase SDKs (Modular) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-auth.js";
        import { getFirestore, collection, serverTimestamp, getDocs, query, orderBy, limit, doc, getDoc, setDoc, runTransaction } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyCNVdBXRTJMkACc46EUmn38Vy4Flz3vDOQ",
            authDomain: "typing-game-c5e84.firebaseapp.com",
            projectId: "typing-game-c5e84",
            storageBucket: "typing-game-c5e84.firebasestorage.app",
            messagingSenderId: "1017813191155",
            appId: "1:1017813191155:web:af354c72711c6488562a86"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();

        window.currentUser = null;

        // Listen to Auth State changes
        onAuthStateChanged(auth, (user) => {
            const loginBtn = document.getElementById("loginBtn");
            const modeSelectBtn = document.getElementById("modeSelectBtn");
            const userDisplay = document.getElementById("userDisplay");

            if (user) {
                window.currentUser = user;
                
                // Show Name at Top
                if(userDisplay) {
                    userDisplay.innerHTML = `COMMANDER: <span>${user.displayName}</span>`;
                }

                // Hide Login, Show Mode Select
                if(loginBtn) loginBtn.classList.add('hidden');
                if(modeSelectBtn) modeSelectBtn.classList.remove('hidden');

                console.log("User logged in:", window.currentUser.displayName);
            } else {
                window.currentUser = null;
                
                // Show Guest at Top
                if(userDisplay) {
                    userDisplay.innerHTML = `GUEST`;
                }

                // Show Login, Hide Mode Select
                if(loginBtn) loginBtn.classList.remove('hidden');
                if(modeSelectBtn) modeSelectBtn.classList.add('hidden');
            }
        });

        // Login with Google
        window.loginWithGoogle = async function () {
            try {
                const result = await signInWithPopup(auth, provider);
                window.currentUser = result.user;
            } catch (err) {
                console.error(err);
                alert("Login failed: " + err.message);
            }
        };

        // Save Score to Firestore (by difficulty mode)
        window.saveScore = async function(score, wpm, difficulty) {
            if (!window.currentUser) {
                console.log("Cannot save score: User not logged in");
                return false;
            }
            
            const collectionName = `leaderboard_${difficulty}`;
            const userDocRef = doc(db, collectionName, window.currentUser.uid);

            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(userDocRef);
                    let shouldSave = false;

                    if (!sfDoc.exists()) {
                        shouldSave = true;
                        console.log("First game. Saving score.");
                    } else {
                        const existingData = sfDoc.data();
                        
                        if (wpm > existingData.wpm) {
                            shouldSave = true;
                            console.log(`New High WPM! Old: ${existingData.wpm}, New: ${wpm}`);
                        }
                    }

                    if (shouldSave) {
                        transaction.set(userDocRef, {
                            name: window.currentUser.displayName,
                            email: window.currentUser.email,
                            score: score,
                            wpm: wpm,
                            difficulty: difficulty,
                            time: serverTimestamp()
                        });
                    }
                });
                console.log("Transaction successfully committed!");
                return true;
            } catch (e) {
                console.error("Transaction failed: ", e);
                return false;
            }
        };

        // Fetch Leaderboard
        window.loadLeaderboard = async function(listId, difficulty) {
            const listEl = document.getElementById(listId);
            if(!listEl) return;
            
            listEl.innerHTML = '<li>Loading...</li>';
            
            try {
                const collectionName = `leaderboard_${difficulty}`;
                const q = query(collection(db, collectionName), orderBy("wpm", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                
                listEl.innerHTML = ''; 
                
                if (querySnapshot.empty) {
                    listEl.innerHTML = '<li>No scores yet. Be the first!</li>';
                    return;
                }

                querySnapshot.forEach((docSnapshot) => {
                    const data = docSnapshot.data();
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span class="lb-name">${data.name}</span>
                        <span class="lb-stats">SCORE: ${data.score}</span>
                        <span class="lb-score">WPM: ${data.wpm}</span>
                    `;
                    listEl.appendChild(li);
                });
            } catch (error) {
                console.error("Error loading leaderboard:", error);
                listEl.innerHTML = '<li>Error loading scores.</li>';
            }
        };
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --primary: #00f3ff;
            --danger: #ff0055;
            --success: #00ff66;
            --warning: #ffaa00;
            --bg: #050510;
            --ui-font: 'Orbitron', sans-serif;
            --type-font: 'Roboto Mono', monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            color: white;
            font-family: var(--ui-font);
            user-select: none;
        }

        /* CRT Scanline Effect */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 999;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            font-size: 1rem;
            padding: 0 20px;
            height: 70px;
            background: rgba(2, 2, 10, 0.85); 
            border-bottom: 2px solid var(--primary);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            text-shadow: 0 0 5px var(--primary);
            gap: 15px;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .hud-stat {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--primary);
            padding: 8px 15px;
            border-radius: 4px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            transition: transform 0.2s;
        }
        
        .hud-stat:active { transform: scale(0.95); }

        .hud-stat span {
            color: var(--primary);
            font-weight: bold;
            font-size: 1.1rem;
        }

        .hud-combo {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: var(--success);
            font-size: 1.5rem;
            text-shadow: 0 0 20px var(--success);
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
            width: 100%;
            pointer-events: none;
        }

        .powerup-display {
            position: absolute;
            top: 90px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--success);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            transform: translateX(50px);
            box-shadow: 0 0 15px var(--success);
        }

        .powerup-display.active {
            opacity: 1;
            transform: translateX(0);
        }

        .current-input {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-family: var(--type-font);
            font-size: 2.5rem;
            color: var(--primary);
            text-shadow: 0 0 15px var(--primary), 0 0 30px var(--primary);
            letter-spacing: 5px;
            opacity: 0.9;
            pointer-events: none;
            transition: transform 0.1s;
            z-index: 5;
        }
        
        .current-input span {
            color: #000;
            background: #fff;
            padding: 0 10px;
            border-radius: 4px;
            margin: 0 2px;
            box-shadow: 0 0 10px #fff;
        }

        /* Damage Flash Overlay */
        #damageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
            z-index: 50;
        }

        /* Fever Mode Overlay */
        #feverOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 100px rgba(0, 243, 255, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 40;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: auto;
            transition: opacity 0.3s;
            overflow-y: auto;
            padding: 20px;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 5px;
            filter: drop-shadow(0 0 15px var(--primary));
            text-align: center;
        }

        h2 {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 5px var(--primary);
            font-weight: 400;
            text-align: center;
        }

        p.subtitle {
            font-family: var(--type-font);
            color: #aaa;
            font-size: 1.2rem;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
        }

        .btn {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: var(--ui-font);
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            pointer-events: auto;
            margin: 10px;
        }

        .btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 30px var(--primary);
            transform: translateY(-2px);
        }

        .btn:disabled {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-small {
            padding: 10px 20px;
            font-size: 1rem;
        }

        .btn-easy { border-color: var(--success); color: var(--success); }
        .btn-easy:hover { background: var(--success); box-shadow: 0 0 30px var(--success); }

        .btn-hard { border-color: var(--warning); color: var(--warning); }
        .btn-hard:hover { background: var(--warning); box-shadow: 0 0 30px var(--warning); }

        .btn-expert { border-color: var(--danger); color: var(--danger); }
        .btn-expert:hover { background: var(--danger); box-shadow: 0 0 30px var(--danger); }

        .mode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            max-width: 900px;
            width: 100%;
            margin: 30px 0;
        }

        .mode-card {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--primary);
            padding: 30px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .mode-card:hover { transform: translateY(-10px); box-shadow: 0 10px 40px rgba(0, 243, 255, 0.4); background: rgba(0, 243, 255, 0.05); }
        .mode-card.easy { border-color: var(--success); }
        .mode-card.easy:hover { box-shadow: 0 10px 40px rgba(0, 255, 102, 0.4); border-color: var(--success); }
        
        .mode-card.hard { border-color: var(--warning); }
        .mode-card.hard:hover { box-shadow: 0 10px 40px rgba(255, 170, 0, 0.4); border-color: var(--warning); }

        .mode-card.expert { border-color: var(--danger); }
        .mode-card.expert:hover { box-shadow: 0 10px 40px rgba(255, 0, 85, 0.4); border-color: var(--danger); }

        .mode-card h3 { font-size: 2rem; margin: 0 0 10px 0; }
        .mode-card.easy h3 { color: var(--success); }
        .mode-card.hard h3 { color: var(--warning); }
        .mode-card.expert h3 { color: var(--danger); }

        .mode-card p { font-family: var(--type-font); color: #aaa; font-size: 0.9rem; margin: 10px 0; }
        .mode-card ul { list-style: none; padding: 0; margin: 15px 0 0 0; font-size: 0.85rem; color: #ccc; text-align: left; }
        .mode-card ul li { padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .mode-card ul li:last-child { border: none; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
            text-align: left;
            min-width: 300px;
        }

        .stat-box {
            border-left: 4px solid var(--danger);
            padding-left: 15px;
            background: rgba(255,255,255,0.05);
            padding: 10px 15px;
            border-radius: 0 5px 5px 0;
        }
        .stat-label { font-size: 0.8rem; color: #888; text-transform: uppercase; letter-spacing: 1px;}
        .stat-value { font-size: 1.5rem; font-weight: bold; font-family: var(--type-font); }

        .leaderboard-container {
            margin-top: 20px;
            width: 100%;
            max-width: 500px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #333;
            padding: 20px;
            border-radius: 8px;
        }

        .leaderboard-container h3 {
            margin: 0 0 15px 0;
            color: var(--success);
            text-align: center;
            text-transform: uppercase;
            font-size: 1.2rem;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        ul.leaderboard-list { list-style: none; padding: 0; margin: 0; }
        ul.leaderboard-list li {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid #222;
            font-family: var(--type-font);
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        ul.leaderboard-list li:hover { background: rgba(255,255,255,0.05); }
        ul.leaderboard-list li:last-child { border-bottom: none; }
        .lb-name { color: #fff; flex: 1; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 120px;}
        .lb-stats { color: #aaa; margin-right: 15px; }
        .lb-score { color: var(--primary); font-weight: bold; text-shadow: 0 0 5px var(--primary); }

        .difficulty-badge {
            display: inline-block;
            padding: 5px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .difficulty-badge.easy { background: var(--success); color: #000; box-shadow: 0 0 10px var(--success); }
        .difficulty-badge.hard { background: var(--warning); color: #000; box-shadow: 0 0 10px var(--warning); }
        .difficulty-badge.expert { background: var(--danger); color: #fff; box-shadow: 0 0 10px var(--danger); }

        @media (max-width: 600px) {
            h1 { font-size: 2.5rem; }
            .stats-grid { grid-template-columns: 1fr; }
            .mode-grid { grid-template-columns: 1fr; }
            .hud-top { height: auto; padding: 10px; flex-direction: column; gap: 5px; }
            .hud-stat { width: 100%; text-align: center; padding: 5px; }
            .hud-combo { top: 120px; }
            .lb-name { max-width: 80px; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <!-- Overlays -->
    <div id="damageOverlay"></div>
    <div id="feverOverlay"></div>

    <div class="current-input" id="inputBufferDisplay"></div>

    <div class="ui-layer" id="hud">
        <div class="hud-top">
            <div class="hud-stat" id="userDisplay">GUEST</div>
            <div class="hud-stat">SCORE: <span id="scoreDisplay">0</span></div>
            <div class="hud-stat">WPM: <span id="wpmDisplay">0</span></div>
            <div class="hud-stat">LIVES: <span id="livesDisplay" style="color:var(--danger)">3</span></div>
        </div>
        <div class="hud-combo" id="comboDisplay">COMBO x1</div>
        <div class="powerup-display" id="powerupDisplay">SHIELD ACTIVE</div>
    </div>

    <!-- START SCREEN -->
    <div class="modal" id="startScreen">
        <h1>TYPING DEFENDER</h1>
        <h2>ULTIMATE EDITION</h2>
        <p class="subtitle">Defend the system from cyber threats. Type words to destroy enemies.<br>High combos trigger Fever Mode for double points!</p>
        
        <button id="modeSelectBtn" class="btn hidden" onclick="showModeSelect()">SELECT MODE</button>
        <button id="loginBtn" class="btn" onclick="loginWithGoogle()">Login with Gmail</button>
        <button class="btn btn-small" style="border-color: #fff; color: #fff;" onclick="openLeaderboardMenu()">LEADERBOARD</button>
    </div>

    <!-- MODE SELECTION SCREEN -->
    <div class="modal hidden" id="modeSelectScreen">
        <h1>SELECT MODE</h1>
        <h2>Choose Your Difficulty</h2>
        
        <div class="mode-grid">
            <div class="mode-card easy" onclick="game.startWithMode('easy')">
                <h3>EASY</h3>
                <p>Cadet Training</p>
                <ul>
                    <li>âœ“ Slower speed</li>
                    <li>âœ“ 5 Lives</li>
                    <li>âœ“ Short words</li>
                    <li>âœ“ Power-ups enabled</li>
                </ul>
            </div>
            
            <div class="mode-card hard" onclick="game.startWithMode('hard')">
                <h3>HARD</h3>
                <p>Soldier Standard</p>
                <ul>
                    <li>âš¡ Normal speed</li>
                    <li>âš¡ 3 Lives</li>
                    <li>âš¡ Mixed words</li>
                    <li>âš¡ Armored enemies</li>
                </ul>
            </div>
            
            <div class="mode-card expert" onclick="game.startWithMode('expert')">
                <h3>EXPERT</h3>
                <p>Elite Cyber-Defender</p>
                <ul>
                    <li>ðŸ”¥ Fast speed</li>
                    <li>ðŸ”¥ 1 Life Only</li>
                    <li>ðŸ”¥ Complex words</li>
                    <li>ðŸ”¥ No Power-ups</li>
                </ul>
            </div>
        </div>
        
        <button class="btn btn-small" onclick="backToStart()">BACK</button>
    </div>

    <!-- LEADERBOARD MENU -->
    <div class="modal hidden" id="leaderboardMenuScreen">
        <h1>HALL OF FAME</h1>
        
        <div style="margin: 20px 0; display: flex; gap: 10px;">
            <button class="btn btn-small btn-easy" onclick="switchLeaderboard('easy')">EASY</button>
            <button class="btn btn-small btn-hard" onclick="switchLeaderboard('hard')">HARD</button>
            <button class="btn btn-small btn-expert" onclick="switchLeaderboard('expert')">EXPERT</button>
        </div>
        
        <div class="difficulty-badge easy" id="leaderboardModeBadge">EASY MODE</div>
        
        <div class="leaderboard-container">
            <h3>Top 10 (By WPM)</h3>
            <ul id="leaderboard-list-start" class="leaderboard-list">
                <li>Loading...</li>
            </ul>
        </div>

        <div style="margin-top: 20px;">
            <button class="btn" onclick="closeLeaderboardMenu()">BACK</button>
        </div>
    </div>

    <!-- PAUSE SCREEN -->
    <div class="modal hidden" id="pauseScreen">
        <h1>SYSTEM PAUSED</h1>
        <h2>Awaiting Input...</h2>
        <button class="btn" onclick="game.togglePause()">RESUME</button>
        <button class="btn btn-small" onclick="game.quitToMenu()" style="border-color:var(--danger); color:var(--danger)">ABORT MISSION</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div class="modal hidden" id="gameOverScreen">
        <h1 style="color: var(--danger); -webkit-text-fill-color: var(--danger);">MISSION FAILED</h1>
        <div class="difficulty-badge easy" id="gameOverModeBadge">EASY MODE</div>
        
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">FINAL SCORE</div>
                <div class="stat-value" id="finalScore">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">MAX WPM</div>
                <div class="stat-value" id="finalWpm">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ACCURACY</div>
                <div class="stat-value" id="finalAcc">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">WORDS DESTROYED</div>
                <div class="stat-value" id="finalWords">0</div>
            </div>
        </div>
        
        <div class="leaderboard-container">
            <h3>Top 10 Defenders</h3>
            <ul id="leaderboard-list" class="leaderboard-list">
                <li>Loading...</li>
            </ul>
        </div>

        <div style="margin-top: 20px;">
            <button class="btn" onclick="game.restart()">RETRY MISSION</button>
            <button class="btn btn-small" onclick="game.quitToMenu()">MAIN MENU</button>
        </div>
    </div>
</div>

<script>
// Current leaderboard mode for menu
let currentLeaderboardMode = 'easy';

window.showModeSelect = function() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('modeSelectScreen').classList.remove('hidden');
};

window.backToStart = function() {
    document.getElementById('modeSelectScreen').classList.add('hidden');
    document.getElementById('startScreen').classList.remove('hidden');
};

window.openLeaderboardMenu = function() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('modeSelectScreen').classList.add('hidden');
    document.getElementById('leaderboardMenuScreen').classList.remove('hidden');
    switchLeaderboard('easy');
};

window.closeLeaderboardMenu = function() {
    document.getElementById('leaderboardMenuScreen').classList.add('hidden');
    document.getElementById('startScreen').classList.remove('hidden');
};

window.switchLeaderboard = function(mode) {
    currentLeaderboardMode = mode;
    const badge = document.getElementById('leaderboardModeBadge');
    badge.className = `difficulty-badge ${mode}`;
    badge.textContent = `${mode.toUpperCase()} MODE`;
    loadLeaderboard('leaderboard-list-start', mode);
};

// --- AUDIO SYSTEM IMPROVED ---
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        // Laser effect: Sawtooth wave dropping pitch
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
        
        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.15);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    },
    playExplosion() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        
        // Lowpass filter for "boom" sound
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.5);

        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    playKeystroke() {
        // Subtle high click
        this.playTone(1200, 'sine', 0.05, 0.03);
    },
    playError() {
        // Low error buzz
        this.playTone(150, 'sawtooth', 0.3, 0.1);
    },
    playPowerup() {
        // Ascending ping
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(1200, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    },
    playShieldHit() {
        // Metallic ping
        this.playTone(2000, 'square', 0.1, 0.05);
    }
};

const WORD_LIST = {
    short: ["nepal","code","data","fire","wind","rain","star","moon","sun","web","app","hack","bug","test","link","node","grid","light","dark","soul","mind","power","laser","neon","cyber","pixel","cloud","server","script","build","debug","async","await","class","style","color","font","alert","score","level","timer","angle","point","line","curve","scale","limit","range","check","token","route","sync","drag","drop","copy","paste","click","hover","focus","blur"],
    medium: ["vector","shield","plasma","rocket","meteor","planet","matrix","thunder","shadow","energy","attack","strike","defend","mission","command","control","network","firewall","database","compile","execute","keyboard","pointer","select","function","promise","boolean","encrypt","decrypt","gradient","transition","transform","overflow","viewport"],
    long: ["rajesh","anil","parth","saroj","malware","spyware","trojan","botnet","kernel","python","database","optimize","bandwidth","sensor","camera","gesture","callback","listener","module","import","export","default","undefined","leaderboard","algorithm","authentication","configuration","documentation","implementation","infrastructure","architecture","performance","responsive","navigation","container","component","framework","encryption","deployment","repository","application"]
};

const ALL_WORDS = [...WORD_LIST.short, ...WORD_LIST.medium, ...WORD_LIST.long];

// --- GRAPHICS CLASSES ---

class Star {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.reset();
        this.y = Math.random() * height; // Start scattered
    }
    
    reset() {
        this.x = Math.random() * this.width;
        this.y = -10;
        this.z = Math.random() * 2 + 0.5; // Depth factor
        this.size = Math.random() * 2;
        this.opacity = Math.random() * 0.5 + 0.1;
        this.speed = this.z * 0.5;
    }

    update(dt, speedMultiplier) {
        this.y += this.speed * speedMultiplier * 60 * dt; // 60 is reference fps
        if (this.y > this.height) this.reset();
    }

    draw(ctx) {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Shockwave {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = 10;
        this.opacity = 1;
        this.lineWidth = 5;
    }

    update(dt) {
        this.radius += 100 * dt;
        this.opacity -= 2 * dt;
        this.lineWidth -= 5 * dt;
    }

    draw(ctx) {
        if (this.opacity <= 0) return;
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.strokeStyle = this.color.replace(')', `, ${this.opacity})`).replace('rgb', 'rgba');
        ctx.lineWidth = Math.max(0.1, this.lineWidth);
        ctx.stroke();
        ctx.restore();
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        
        this.state = 'MENU';
        this.difficulty = 'easy';
        this.lastTime = 0;
        this.pauseTime = 0;
        
        this.spawnTimer = null;
        
        this.player = new Player(this);
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.shockwaves = [];
        this.powerups = [];
        this.stars = [];
        
        // Background stars initialization
        for(let i=0; i<100; i++) this.stars.push(new Star(this.width, this.height));
        
        this.score = 0;
        this.combo = 0;
        this.lives = 3;
        this.maxLives = 3;
        this.startTime = 0;
        this.wordsTyped = 0;
        this.totalKeystrokes = 0;
        this.missedKeystrokes = 0;
        this.difficultyMultiplier = 1;
        
        this.activePowerup = null;
        this.powerupTimer = 0;
        
        this.shake = 0;
        this.currentInput = ""; 

        this.resize();
        window.addEventListener('resize', () => this.resize());
        document.addEventListener('keydown', (e) => this.handleInput(e));
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.togglePause();
            }
        });

        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        this.player.y = this.height - 80;
        this.player.x = this.width / 2;
        this.stars.forEach(s => { s.width = this.width; s.height = this.height; });
    }

    togglePause() {
        if (this.state === 'PLAYING') {
            this.state = 'PAUSED';
            this.pauseTime = performance.now();
            document.getElementById('pauseScreen').classList.remove('hidden');
            if (AudioSys.ctx) AudioSys.ctx.suspend();
            
            if (this.spawnTimer) {
                clearTimeout(this.spawnTimer);
                this.spawnTimer = null;
            }

        } else if (this.state === 'PAUSED') {
            this.state = 'PLAYING';
            document.getElementById('pauseScreen').classList.add('hidden');
            
            const pauseDuration = performance.now() - this.pauseTime;
            this.lastTime += pauseDuration;
            
            if (AudioSys.ctx) AudioSys.ctx.resume();
            
            this.spawnEnemy();
        }
    }

    startWithMode(mode) {
        this.difficulty = mode;
        this.start();
    }

    start() {
        AudioSys.init();
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('modeSelectScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('pauseScreen').classList.add('hidden');
        
        // Reset Overlays
        document.getElementById('damageOverlay').style.opacity = 0;
        document.getElementById('feverOverlay').style.opacity = 0;
        
        this.reset();
        this.state = 'PLAYING';
        this.startTime = Date.now();
        this.lastTime = performance.now();
        this.spawnEnemy();
    }

    restart() {
        this.start();
    }

    quitToMenu() {
        this.reset();
        this.state = 'MENU';
        document.getElementById('pauseScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('modeSelectScreen').classList.add('hidden');
        document.getElementById('startScreen').classList.remove('hidden');
    }

    reset() {
        if (this.spawnTimer) {
            clearTimeout(this.spawnTimer);
            this.spawnTimer = null;
        }

        switch(this.difficulty) {
            case 'easy': this.maxLives = 5; this.difficultyMultiplier = 0.7; break;
            case 'hard': this.maxLives = 3; this.difficultyMultiplier = 1; break;
            case 'expert': this.maxLives = 1; this.difficultyMultiplier = 1.5; break;
        }

        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.shockwaves = [];
        this.powerups = [];
        this.score = 0;
        this.combo = 0;
        this.lives = this.maxLives;
        this.wordsTyped = 0;
        this.totalKeystrokes = 0;
        this.missedKeystrokes = 0;
        this.currentInput = "";
        this.activePowerup = null;
        this.powerupTimer = 0;
        this.updateHUD();
        this.updateInputDisplay();
    }

    getWordForDifficulty() {
        switch(this.difficulty) {
            case 'easy':
                return Math.random() > 0.3 
                    ? WORD_LIST.short[Math.floor(Math.random() * WORD_LIST.short.length)]
                    : WORD_LIST.medium[Math.floor(Math.random() * WORD_LIST.medium.length)];
            case 'hard':
                return Math.random() > 0.5
                    ? WORD_LIST.medium[Math.floor(Math.random() * WORD_LIST.medium.length)]
                    : WORD_LIST.long[Math.floor(Math.random() * WORD_LIST.long.length)];
            case 'expert':
                return Math.random() > 0.3
                    ? WORD_LIST.long[Math.floor(Math.random() * WORD_LIST.long.length)]
                    : WORD_LIST.medium[Math.floor(Math.random() * WORD_LIST.medium.length)];
            default:
                return ALL_WORDS[Math.floor(Math.random() * ALL_WORDS.length)];
        }
    }

    spawnEnemy() {
        if (this.state !== 'PLAYING') return;
        
        const word = this.getWordForDifficulty();
        const x = Math.random() * (this.width - 150) + 75;
        const y = -50; 
        const speed = (Math.random() * 0.5 + 0.5) * this.difficultyMultiplier;
        
        let type = 'NORMAL';
        if (this.difficulty === 'hard' || this.difficulty === 'expert') {
            type = Math.random() > 0.7 ? 'ARMORED' : 'NORMAL';
        }
        
        this.enemies.push(new Enemy(x, y, word, speed, type));
        
        if (this.difficulty !== 'expert' && Math.random() > 0.95 && this.powerups.length < 2) {
            this.spawnPowerup();
        }
        
        let nextSpawn = Math.max(800, 2000 - (this.difficultyMultiplier * 200));
        if (this.difficulty === 'expert') nextSpawn = Math.max(600, nextSpawn - 300);
        
        this.spawnTimer = setTimeout(() => this.spawnEnemy(), nextSpawn);
    }

    spawnPowerup() {
        const types = ['shield', 'slowtime', 'multikill'];
        const type = types[Math.floor(Math.random() * types.length)];
        const x = Math.random() * (this.width - 150) + 75;
        const y = -50;
        this.powerups.push(new Powerup(x, y, type));
    }

    handleInput(e) {
        if (this.state !== 'PLAYING') return;
        
        if (e.key.length !== 1) return;
        const key = e.key.toLowerCase();
        
        if (!/[a-z]/.test(key)) return;

        this.totalKeystrokes++;
        
        const prospectiveInput = this.currentInput + key;
        const matches = this.enemies.filter(enemy => enemy.word.startsWith(prospectiveInput));
        
        if (matches.length > 0) {
            const exactMatches = matches.filter(enemy => enemy.word === prospectiveInput);
            
            if (exactMatches.length > 0) {
                exactMatches.forEach(enemy => this.destroyEnemy(enemy));
                const remainingMatches = matches.filter(enemy => enemy.word !== prospectiveInput);
                this.currentInput = remainingMatches.length > 0 ? prospectiveInput : "";
            } else {
                this.currentInput = prospectiveInput;
                AudioSys.playKeystroke();
                matches.forEach(match => {
                    this.createBullet(this.player.x, this.player.y - 40, match.x, match.y);
                });
            }
            
        } else {
            this.missedKeystrokes++;
            this.breakCombo();
            AudioSys.playError();
            this.shake = 3;
        }
        
        this.updateHUD();
        this.updateInputDisplay();
    }

    destroyEnemy(enemy) {
        let points = 10 * (1 + Math.floor(this.combo / 5)) * (enemy.type === 'ARMORED' ? 2 : 1);
        if (this.activePowerup === 'multikill') points *= 2;
        
        this.score += points;
        this.combo++;
        this.wordsTyped++;
        
        if (this.difficulty !== 'expert') this.difficultyMultiplier += 0.01;
        else this.difficultyMultiplier += 0.02;
        
        AudioSys.playExplosion();
        const color = enemy.type === 'ARMORED' ? 'rgb(255, 170, 0)' : 'rgb(0, 243, 255)';
        this.createExplosion(enemy.x, enemy.y, color);
        this.shockwaves.push(new Shockwave(enemy.x, enemy.y, color));
        
        this.shake = 5;
        this.enemies = this.enemies.filter(e => e !== enemy);
        
        this.updateHUD();
        this.animateCombo();
    }

    breakCombo() {
        this.combo = 0;
        this.currentInput = ""; 
        this.updateInputDisplay();
    }

    createBullet(sx, sy, tx, ty) {
        AudioSys.playShoot();
        this.bullets.push(new Bullet(sx, sy, tx, ty));
    }

    createExplosion(x, y, color) {
        const count = this.activePowerup === 'multikill' ? 30 : 20;
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    activatePowerup(type) {
        this.activePowerup = type;
        this.powerupTimer = 10; 
        
        const display = document.getElementById('powerupDisplay');
        display.classList.add('active');
        
        switch(type) {
            case 'shield':
                display.textContent = 'ðŸ›¡ï¸ SHIELD ACTIVE';
                display.style.borderColor = 'var(--primary)';
                break;
            case 'slowtime':
                display.textContent = 'â° SLOW MOTION';
                display.style.borderColor = 'var(--warning)';
                AudioSys.playPowerup();
                break;
            case 'multikill':
                display.textContent = 'âš¡ DOUBLE POINTS';
                display.style.borderColor = 'var(--danger)';
                AudioSys.playPowerup();
                break;
        }
    }

    updatePowerup(dt) {
        if (this.activePowerup) {
            this.powerupTimer -= dt;
            if (this.powerupTimer <= 0) {
                this.activePowerup = null;
                document.getElementById('powerupDisplay').classList.remove('active');
            }
        }
    }

    loseLife() {
        if (this.activePowerup === 'shield') {
            this.activePowerup = null;
            document.getElementById('powerupDisplay').classList.remove('active');
            AudioSys.playShieldHit();
            this.createExplosion(this.player.x, this.player.y, 'rgb(0, 243, 255)');
            this.shockwaves.push(new Shockwave(this.player.x, this.player.y, 'rgb(0, 243, 255)'));
            this.shake = 8;
            
            // Shield break visual
            const overlay = document.getElementById('damageOverlay');
            overlay.style.background = 'radial-gradient(circle, transparent 50%, rgba(0, 243, 255, 0.6) 100%)';
            overlay.style.opacity = 1;
            setTimeout(() => overlay.style.opacity = 0, 100);

        } else {
            this.lives--;
            this.updateHUD();
            AudioSys.playExplosion();
            this.createExplosion(this.player.x, this.player.y, 'rgb(255, 0, 85)');
            this.shake = 15;
            
            // Damage visual
            const overlay = document.getElementById('damageOverlay');
            overlay.style.opacity = 1;
            setTimeout(() => overlay.style.opacity = 0, 200);
            
            if (this.lives <= 0) this.gameOver();
        }
    }

    updateInputDisplay() {
        const el = document.getElementById('inputBufferDisplay');
        if (!this.currentInput) {
            el.style.opacity = 0;
        } else {
            el.style.opacity = 0.9;
            // Highlight typed part vs remaining
            el.innerHTML = this.currentInput; 
            el.style.transform = "translateX(-50%) scale(1.1)";
            setTimeout(() => el.style.transform = "translateX(-50%) scale(1)", 50);
        }
    }

    animateCombo() {
        const el = document.getElementById('comboDisplay');
        el.innerText = `COMBO x${this.combo}`;
        el.style.opacity = 1;
        el.style.transform = "translateX(-50%) scale(1.5)";
        el.style.color = this.combo > 10 ? 'var(--primary)' : 'var(--success)';
        
        // Fever Mode
        if (this.combo > 10) {
            document.getElementById('feverOverlay').style.opacity = 1;
        } else {
            document.getElementById('feverOverlay').style.opacity = 0;
        }

        setTimeout(() => {
            el.style.transform = "translateX(-50%) scale(1)";
            el.style.opacity = this.combo > 1 ? 1 : 0;
        }, 100);
    }

    updateHUD() {
        document.getElementById('scoreDisplay').innerText = this.score;
        document.getElementById('livesDisplay').innerText = this.lives;
        document.getElementById('comboDisplay').innerText = `COMBO x${this.combo}`;
        
        const elapsedMin = (Date.now() - this.startTime) / 60000;
        const wpm = elapsedMin > 0 ? Math.floor((this.wordsTyped) / elapsedMin) : 0;
        document.getElementById('wpmDisplay').innerText = wpm;
    }

    async gameOver() {
        this.state = 'GAMEOVER';
        if (this.spawnTimer) {
            clearTimeout(this.spawnTimer);
            this.spawnTimer = null;
        }

        const elapsedMin = (Date.now() - this.startTime) / 60000;
        const finalWpm = elapsedMin > 0 ? Math.floor((this.wordsTyped) / elapsedMin) : 0;
        const accuracy = this.totalKeystrokes > 0 
            ? Math.floor(((this.totalKeystrokes - this.missedKeystrokes) / this.totalKeystrokes) * 100) 
            : 0;

        document.getElementById('finalScore').innerText = this.score;
        document.getElementById('finalWpm').innerText = finalWpm;
        document.getElementById('finalAcc').innerText = accuracy + '%';
        document.getElementById('finalWords').innerText = this.wordsTyped;
        
        const badge = document.getElementById('gameOverModeBadge');
        badge.className = `difficulty-badge ${this.difficulty}`;
        badge.textContent = `${this.difficulty.toUpperCase()} MODE`;
        
        document.getElementById('gameOverScreen').classList.remove('hidden');

        if (window.currentUser) await saveScore(this.score, finalWpm, this.difficulty);
        else console.log("User not logged in. Score not saved.");
        
        loadLeaderboard('leaderboard-list', this.difficulty);
    }

    loop(timestamp) {
        // Cap delta time to prevent huge jumps
        let dt = (timestamp - this.lastTime) / 1000;
        if (dt > 0.1) dt = 0.1;
        this.lastTime = timestamp;

        // Clear Canvas with trail effect
        this.ctx.fillStyle = 'rgba(5, 5, 16, 0.6)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.ctx.save();
        if (this.shake > 0) {
            const sx = (Math.random() - 0.5) * this.shake;
            const sy = (Math.random() - 0.5) * this.shake;
            this.ctx.translate(sx, sy);
            this.shake *= 0.9;
            if (this.shake < 0.5) this.shake = 0;
        }

        // Draw Stars (Background)
        const starSpeed = this.state === 'PLAYING' ? (this.activePowerup === 'slowtime' ? 2 : 5) : 0.5;
        this.stars.forEach(star => {
            star.update(dt, starSpeed);
            star.draw(this.ctx);
        });

        if (this.state === 'PLAYING') {
            this.updatePowerup(dt);
            
            this.player.update(dt);
            this.player.draw(this.ctx);

            const activeMatches = this.enemies.filter(e => 
                this.currentInput.length > 0 && e.word.startsWith(this.currentInput)
            );

            const timeScale = this.activePowerup === 'slowtime' ? 0.5 : 1;

            this.enemies.forEach((enemy, index) => {
                enemy.update(dt * timeScale);
                const isMatch = activeMatches.includes(enemy);
                const isLocked = isMatch && activeMatches.length === 1; 
                enemy.draw(this.ctx, this.currentInput, isMatch, isLocked);
                
                if (enemy.y > this.height - 50) {
                    this.enemies.splice(index, 1);
                    this.loseLife();
                }
            });

            this.powerups.forEach((powerup, i) => {
                powerup.update(dt * timeScale);
                powerup.draw(this.ctx);
                
                if (Math.hypot(powerup.x - this.player.x, powerup.y - this.player.y) < 40) {
                    this.activatePowerup(powerup.type);
                    this.powerups.splice(i, 1);
                }
                
                if (powerup.y > this.height) this.powerups.splice(i, 1);
            });

            this.bullets.forEach((b, i) => {
                b.update(dt);
                b.draw(this.ctx);
                if (b.life <= 0) this.bullets.splice(i, 1);
            });

            this.particles.forEach((p, i) => {
                p.update(dt);
                p.draw(this.ctx);
                if (p.life <= 0) this.particles.splice(i, 1);
            });
            
            this.shockwaves.forEach((s, i) => {
                s.update(dt);
                s.draw(this.ctx);
                if (s.opacity <= 0) this.shockwaves.splice(i, 1);
            });

            // Lock-on lines
            if (activeMatches.length > 0) {
                activeMatches.forEach(target => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.player.x, this.player.y - 20);
                    this.ctx.lineTo(target.x, target.y);
                    this.ctx.strokeStyle = activeMatches.length === 1 
                        ? 'rgba(0, 243, 255, 0.6)' 
                        : 'rgba(0, 243, 255, 0.2)';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                });
            }
        } else if (this.state === 'PAUSED' || this.state === 'GAMEOVER' || this.state === 'MENU') {
            this.stars.forEach(star => {
                star.update(dt, 0.2);
                star.draw(this.ctx);
            });
            
            this.player.draw(this.ctx);

            const activeMatches = this.enemies.filter(e => 
                this.currentInput.length > 0 && e.word.startsWith(this.currentInput)
            );

            this.enemies.forEach((enemy) => {
                const isMatch = activeMatches.includes(enemy);
                const isLocked = isMatch && activeMatches.length === 1;
                enemy.draw(this.ctx, this.currentInput, isMatch, isLocked);
            });
            
            this.powerups.forEach((p) => p.draw(this.ctx));
            this.bullets.forEach((b) => b.draw(this.ctx));
            this.particles.forEach((p) => p.draw(this.ctx));
            this.shockwaves.forEach((s) => s.draw(this.ctx));
        }

        this.ctx.restore();
        requestAnimationFrame((t) => this.loop(t));
    }
}

class Player {
    constructor(game) {
        this.game = game;
        this.x = game.width / 2;
        this.y = game.height - 80;
        this.width = 50;
        this.height = 50;
    }

    update(dt) {
        this.y = this.game.height - 80 + Math.sin(Date.now() / 500) * 5;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.game.activePowerup === 'shield') {
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.6)';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'var(--primary)';
            ctx.beginPath();
            ctx.arc(0, 0, 45, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0, 0, 50, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = 'rgba(0, 243, 255, 0.5)';
        ctx.fillStyle = '#0a1a2a';
        ctx.beginPath();
        ctx.moveTo(0, -30);
        ctx.lineTo(20, 10);
        ctx.lineTo(30, 20);
        ctx.lineTo(-30, 20);
        ctx.lineTo(-20, 10);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#00f3ff';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#00f3ff';
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00f3ff';
        ctx.fillStyle = 'rgba(0, 243, 255, 0.8)';
        ctx.beginPath();
        ctx.moveTo(-10, 20);
        ctx.lineTo(0, 35 + Math.random() * 10);
        ctx.lineTo(10, 20);
        ctx.fill();
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, word, speed, type) {
        this.x = x;
        this.y = y;
        this.word = word;
        this.type = type;
        this.speed = speed;
        this.wobbleOffset = Math.random() * Math.PI * 2;
    }

    update(dt) {
        this.y += this.speed;
        this.wobbleOffset += dt * 2;
    }

    draw(ctx, inputBuffer, isMatch, isLocked) {
        ctx.save();
        ctx.translate(this.x + (Math.sin(this.wobbleOffset) * 5), this.y);

        let baseColor = '#ffffff';
        let glowColor = 'rgba(255, 255, 255, 0.2)';
        
        if (this.type === 'ARMORED') {
            baseColor = '#ffaa00';
            glowColor = 'rgba(255, 170, 0, 0.2)';
        }

        if (isMatch) {
            if (isLocked) {
                baseColor = '#ff0055'; 
                glowColor = 'rgba(255, 0, 85, 0.4)';
            } else {
                baseColor = '#00f3ff'; 
                glowColor = 'rgba(0, 243, 255, 0.4)';
            }
        }

        ctx.shadowBlur = isMatch ? 20 : 10;
        ctx.shadowColor = baseColor;
        
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';

        ctx.beginPath();
        if (this.type === 'ARMORED') {
            ctx.moveTo(0, 20);
            ctx.lineTo(15, -10);
            ctx.lineTo(25, 0); 
            ctx.lineTo(15, 10);
            ctx.lineTo(-15, 10);
            ctx.lineTo(-25, 0);
            ctx.lineTo(-15, -10);
        } else {
            ctx.moveTo(0, 25);
            ctx.lineTo(10, -5);
            ctx.lineTo(20, -10);
            ctx.lineTo(0, -5); 
            ctx.lineTo(-20, -10);
            ctx.lineTo(-10, -5);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        if (isLocked) {
            ctx.strokeStyle = '#ff0055';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 5, 35, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.fillStyle = '#ff0055';
            ctx.beginPath();
            ctx.moveTo(-5, 40);
            ctx.lineTo(5, 40);
            ctx.lineTo(0, 50);
            ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.font = 'bold 20px "Roboto Mono"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const matchIndex = inputBuffer.length;
        const typedPart = this.word.substring(0, matchIndex);
        const remainPart = this.word.substring(matchIndex);
        
        const totalWidth = ctx.measureText(this.word).width;
        const startX = -totalWidth / 2;

        if (isMatch && matchIndex > 0) {
            ctx.fillStyle = 'rgba(0, 255, 102, 0.9)';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff66';
            ctx.fillText(typedPart, startX + ctx.measureText(typedPart).width/2, -30);
            ctx.shadowBlur = 0;
        } else if (!isMatch && matchIndex > 0) {
            ctx.fillStyle = '#555';
            ctx.fillText(this.word, startX + totalWidth/2, -30);
        } else {
            ctx.fillStyle = '#fff';
            ctx.fillText(this.word, startX + totalWidth/2, -30);
        }

        if (isMatch && remainPart.length > 0) {
            ctx.fillStyle = isLocked ? '#ff0055' : '#fff';
            ctx.fillText(remainPart, startX + ctx.measureText(typedPart).width + ctx.measureText(remainPart).width/2, -30);
        }

        ctx.restore();
    }
}

class Powerup {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.speed = 1;
        this.wobble = 0;
    }

    update(dt) {
        this.y += this.speed;
        this.wobble += dt * 3;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y + Math.sin(this.wobble) * 10);
        
        let color;
        let symbol;
        switch(this.type) {
            case 'shield': color = '#00f3ff'; symbol = 'ðŸ›¡ï¸'; break;
            case 'slowtime': color = '#ffaa00'; symbol = 'â°'; break;
            case 'multikill': color = '#ff0055'; symbol = 'âš¡'; break;
        }
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = color;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        
        ctx.beginPath();
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(symbol, 0, 0);
        
        ctx.restore();
    }
}

class Bullet {
    constructor(sx, sy, tx, ty) {
        this.x = sx;
        this.y = sy;
        this.tx = tx;
        this.ty = ty;
        this.speed = 1500; 
        const angle = Math.atan2(ty - sy, tx - sx);
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.life = 1.0;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        const dist = Math.hypot(this.x - this.tx, this.y - this.ty);
        if (dist < 50) this.life = 0; 
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00f3ff';
        ctx.fillStyle = '#ccfbff';
        ctx.beginPath();
        ctx.rect(-15, -2, 30, 4);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.rect(-15, -2, 10, 4);
        ctx.fill();
        
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 200 + 50;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.01;
        this.gravity = 100;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vy += this.gravity * dt; // Gravity effect
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const game = new Game();

</script>
</body>
</html>
