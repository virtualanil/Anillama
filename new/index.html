<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Tags -->
    <title>Typing Game - Nepali Typing Game</title>
    <meta name="description" content="Play Typing Defender, a free 3D typing shooter game. Improve your WPM and accuracy while defending system from cyber enemies.">
    <meta name="author" content="Anil Lama">

    <!-- Firebase SDKs (Modular) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-auth.js";
        import { getFirestore, collection, serverTimestamp, getDocs, query, orderBy, limit, doc, getDoc, setDoc, runTransaction } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

        // Firebase Config
        const firebaseConfig = {
        apiKey: "AIzaSyCNVdBXRTJMkACc46EUmn38Vy4Flz3vDOQ",
        authDomain: "typing-game-c5e84.firebaseapp.com",
        projectId: "typing-game-c5e84",
        storageBucket: "typing-game-c5e84.firebasestorage.app",
        messagingSenderId: "1017813191155",
        appId: "1:1017813191155:web:af354c72711c6488562a86"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();

        window.currentUser = null;

        // Listen to Auth State changes
        onAuthStateChanged(auth, (user) => {
            const loginBtn = document.getElementById("loginBtn");
            const startBtn = document.getElementById("startBtn");
            const userDisplay = document.getElementById("userDisplay");

            if (user) {
                window.currentUser = user;
                
                // Show Name at Top
                if(userDisplay) {
                    userDisplay.innerHTML = `CMD: <span>${user.displayName.split(' ')[0]}</span>`;
                }

                // Hide Login, Show Start
                if(loginBtn) loginBtn.classList.add('hidden');
                if(startBtn) startBtn.classList.remove('hidden');

                console.log("User logged in:", window.currentUser.displayName);
            } else {
                window.currentUser = null;
                
                // Show Guest at Top
                if(userDisplay) {
                    userDisplay.innerHTML = `GUEST`;
                }

                // Show Login, Hide Start
                if(loginBtn) loginBtn.classList.remove('hidden');
                if(startBtn) startBtn.classList.add('hidden');
            }
        });

        // Login with Google
        window.loginWithGoogle = async function () {
            try {
                const result = await signInWithPopup(auth, provider);
                window.currentUser = result.user;
            } catch (err) {
                console.error(err);
                alert("Login failed: " + err.message);
            }
        };

        // Save Score to Firestore (UPDATED LOGIC: Prioritize WPM)
        window.saveScore = async function(score, wpm) {
            if (!window.currentUser) {
                console.log("Cannot save score: User not logged in");
                return false;
            }
            
            const userDocRef = doc(db, "leaderboard", window.currentUser.uid);

            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(userDocRef);
                    let shouldSave = false;

                    if (!sfDoc.exists()) {
                        shouldSave = true;
                        console.log("First game. Saving score.");
                    } else {
                        const existingData = sfDoc.data();
                        
                        // CHANGE: Now comparing WPM instead of Score
                        if (wpm > existingData.wpm) {
                            shouldSave = true;
                            console.log(`New High WPM! Old: ${existingData.wpm}, New: ${wpm}`);
                        } else {
                            console.log(`WPM ${wpm} is not higher than current best ${existingData.wpm}. Not saving.`);
                        }
                    }

                    if (shouldSave) {
                        transaction.set(userDocRef, {
                            name: window.currentUser.displayName,
                            email: window.currentUser.email,
                            score: score, 
                            wpm: wpm,
                            time: serverTimestamp()
                        });
                    }
                });
                console.log("Transaction successfully committed!");
                return true;
            } catch (e) {
                console.error("Transaction failed: ", e);
                return false;
            }
        };

        // Fetch Leaderboard
        window.loadLeaderboard = async function(listId = 'leaderboard-list') {
            const listEl = document.getElementById(listId);
            if(!listEl) return;
            
            listEl.innerHTML = '<li>Loading...</li>';
            
            try {
                const q = query(collection(db, "leaderboard"), orderBy("wpm", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                
                listEl.innerHTML = ''; 
                
                if (querySnapshot.empty) {
                    listEl.innerHTML = '<li>No scores yet. Be the first!</li>';
                    return;
                }

                querySnapshot.forEach((docSnapshot) => {
                    const data = docSnapshot.data();
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span class="lb-name">${data.name}</span>
                        <span class="lb-stats">SCORE: ${data.score}</span>
                        <span class="lb-score">WPM: ${data.wpm}</span>
                    `;
                    listEl.appendChild(li);
                });
            } catch (error) {
                console.error("Error loading leaderboard:", error);
                listEl.innerHTML = '<li>Error loading scores.</li>';
            }
        };
    </script>

       <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --primary: #00f3ff;
            --danger: #ff0055;
            --success: #00ff66;
            --bg: #050510;
            --ui-font: 'Orbitron', sans-serif;
            --type-font: 'Roboto Mono', monospace;
        }

        * {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            color: white;
            font-family: var(--ui-font);
            user-select: none;
            touch-action: none; /* Prevents scrolling on mobile */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            z-index: 5;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            font-size: 0.9rem;
            text-shadow: 0 0 10px var(--primary);
            gap: 5px;
        }

        .hud-stat {
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border: 1px solid var(--primary);
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .hud-stat span {
            color: var(--primary);
            font-weight: bold;
        }

        .hud-combo {
            text-align: center;
            color: var(--success);
            font-size: 1.2rem;
            text-shadow: 0 0 20px var(--success);
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
        }

        .current-input {
            position: absolute;
            bottom: 260px; /* Moved up for keyboard */
            left: 50%;
            transform: translateX(-50%);
            font-family: var(--type-font);
            font-size: 1.5rem;
            color: var(--primary);
            text-shadow: 0 0 10px var(--primary);
            letter-spacing: 2px;
            opacity: 0.8;
            pointer-events: none;
            transition: transform 0.1s;
            width: 90%;
            text-align: center;
        }
        
        .current-input span {
            color: #fff;
            background: var(--danger);
            padding: 0 5px;
            border-radius: 4px;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            transition: opacity 0.3s;
            overflow-y: auto;
            padding: 20px;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 3px;
            filter: drop-shadow(0 0 15px var(--primary));
            text-align: center;
        }

        h2 {
            font-size: 1rem;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 5px var(--primary);
            font-weight: 400;
            text-align: center;
        }

        p.subtitle {
            font-family: var(--type-font);
            color: #aaa;
            font-size: 0.9rem;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            line-height: 1.4;
        }

        .btn {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 12px 30px;
            font-size: 1.2rem;
            font-family: var(--ui-font);
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            pointer-events: auto;
            margin: 8px;
            width: 80%;
            max-width: 300px;
        }

        .btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 30px var(--primary);
        }

        .btn:disabled {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-small {
            padding: 8px 15px;
            font-size: 0.9rem;
            width: auto;
            max-width: none;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            text-align: left;
            width: 90%;
            max-width: 400px;
        }

        .stat-box {
            border-left: 4px solid var(--danger);
            padding-left: 10px;
        }
        
        .stat-label { font-size: 0.7rem; color: #888; }
        .stat-value { font-size: 1.2rem; font-weight: bold; }

        /* Leaderboard Styles */
        .leaderboard-container {
            margin-top: 20px;
            width: 100%;
            max-width: 400px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 8px;
        }
        .leaderboard-container h3 {
            margin: 0 0 10px 0;
            color: var(--success);
            text-align: center;
            text-transform: uppercase;
            font-size: 1rem;
        }
        ul.leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        ul.leaderboard-list li {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #333;
            font-family: var(--type-font);
            font-size: 0.8rem;
        }
        ul.leaderboard-list li:last-child { border-bottom: none; }
        .lb-name { color: #fff; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 80px;}
        .lb-stats { color: #aaa; margin-right: 10px; font-size: 0.75rem;}
        .lb-score { color: var(--primary); font-weight: bold; }

        /* MOBILE KEYBOARD STYLES */
        .virtual-keyboard {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(5, 10, 20, 0.95);
            border-top: 1px solid #333;
            padding: 5px;
            z-index: 15;
            display: none; /* Hidden by default on desktop */
            flex-direction: column;
            align-items: center;
            padding-bottom: env(safe-area-inset-bottom);
        }

        .kb-row {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 5px;
        }

        .kb-key {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            font-family: var(--type-font);
            font-size: 14px;
            height: 45px;
            margin: 0 2px;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            max-width: 35px;
            user-select: none;
            cursor: pointer;
            box-shadow: 0 2px 0 #000;
            transition: background 0.1s;
        }

        .kb-key:active {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 5px var(--primary);
            transform: translateY(2px);
        }

        .kb-key.wide {
            flex: 1.5;
            max-width: 60px;
            font-size: 12px;
        }

        /* Media Queries for Mobile */
        @media (max-width: 768px) {
            .virtual-keyboard {
                display: flex;
            }
            .current-input {
                bottom: 280px;
            }
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 400px) {
            h1 { font-size: 2rem; }
            .kb-key { height: 40px; font-size: 12px; }
            .current-input { bottom: 260px; font-size: 1.2rem; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Visual Input Buffer -->
    <div class="current-input" id="inputBufferDisplay"></div>

    <!-- VIRTUAL KEYBOARD (Mobile Only) -->
    <div class="virtual-keyboard" id="virtualKeyboard">
        <div class="kb-row">
            <div class="kb-key" data-key="q">Q</div>
            <div class="kb-key" data-key="w">W</div>
            <div class="kb-key" data-key="e">E</div>
            <div class="kb-key" data-key="r">R</div>
            <div class="kb-key" data-key="t">T</div>
            <div class="kb-key" data-key="y">Y</div>
            <div class="kb-key" data-key="u">U</div>
            <div class="kb-key" data-key="i">I</div>
            <div class="kb-key" data-key="o">O</div>
            <div class="kb-key" data-key="p">P</div>
        </div>
        <div class="kb-row">
            <div class="kb-key" data-key="a">A</div>
            <div class="kb-key" data-key="s">S</div>
            <div class="kb-key" data-key="d">D</div>
            <div class="kb-key" data-key="f">F</div>
            <div class="kb-key" data-key="g">G</div>
            <div class="kb-key" data-key="h">H</div>
            <div class="kb-key" data-key="j">J</div>
            <div class="kb-key" data-key="k">K</div>
            <div class="kb-key" data-key="l">L</div>
        </div>
        <div class="kb-row">
            <div class="kb-key wide" data-key="backspace">âŒ«</div>
            <div class="kb-key" data-key="z">Z</div>
            <div class="kb-key" data-key="x">X</div>
            <div class="kb-key" data-key="c">C</div>
            <div class="kb-key" data-key="v">V</div>
            <div class="kb-key" data-key="b">B</div>
            <div class="kb-key" data-key="n">N</div>
            <div class="kb-key" data-key="m">M</div>
            <div class="kb-key wide" data-key=" ">SPACE</div>
        </div>
    </div>

    <div class="ui-layer" id="hud">
        <div class="hud-top">
            <div class="hud-stat" id="userDisplay">GUEST</div>
            <div class="hud-stat">SCORE: <span id="scoreDisplay">0</span></div>
            <div class="hud-stat">WPM: <span id="wpmDisplay">0</span></div>
        </div>
        <div class="hud-combo" id="comboDisplay">COMBO x1</div>
    </div>

    <!-- START SCREEN -->
    <div class="modal" id="startScreen">
        <h1>TYPING GAME</h1>
        <h2>BY ANIL LAMA </h2>
        <p class="subtitle">Destroy enemies by typing words.<br>
        Login to save your High Score.<br>
        Press ESC to Pause.</p>
        
        <button id="startBtn" class="btn hidden" onclick="game.start()">START GAME</button>
        <button id="loginBtn" class="btn" onclick="loginWithGoogle()">Login with Gmail</button>
        <button class="btn btn-small" onclick="openLeaderboardMenu()">LEADERBOARD</button>
    </div>

    <!-- LEADERBOARD MENU -->
    <div class="modal hidden" id="leaderboardMenuScreen">
        <h1>TOP DEFENDERS</h1>
        <div class="leaderboard-container">
            <h3>Top 10 (By WPM)</h3>
            <ul id="leaderboard-list-start" class="leaderboard-list">
                <li>Loading...</li>
            </ul>
        </div>
        <div style="margin-top: 20px;">
            <button class="btn" onclick="closeLeaderboardMenu()">BACK</button>
        </div>
    </div>

    <!-- PAUSE SCREEN -->
    <div class="modal hidden" id="pauseScreen">
        <h1>GAME PAUSED</h1>
        <button class="btn" onclick="game.togglePause()">RESUME</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div class="modal hidden" id="gameOverScreen">
        <h1 style="color: var(--danger); -webkit-text-fill-color: var(--danger);">GAME OVER</h1>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">FINAL SCORE</div>
                <div class="stat-value" id="finalScore">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">MAX WPM</div>
                <div class="stat-value" id="finalWpm">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ACCURACY</div>
                <div class="stat-value" id="finalAcc">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">WORDS DESTROYED</div>
                <div class="stat-value" id="finalWords">0</div>
            </div>
        </div>
        
        <div class="leaderboard-container">
            <h3>Top 10 Defenders (By WPM)</h3>
            <ul id="leaderboard-list" class="leaderboard-list">
                <li>Loading...</li>
            </ul>
        </div>

        <div style="margin-top: 20px;">
            <button class="btn" onclick="game.restart()">TRY AGAIN</button>
        </div>
    </div>
</div>

<script>
// Helper Functions for Menus
window.openLeaderboardMenu = function() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('leaderboardMenuScreen').classList.remove('hidden');
    loadLeaderboard('leaderboard-list-start');
};

window.closeLeaderboardMenu = function() {
    document.getElementById('leaderboardMenuScreen').classList.add('hidden');
    document.getElementById('startScreen').classList.remove('hidden');
};

// Virtual Keyboard Logic
const keys = document.querySelectorAll('.kb-key');
keys.forEach(key => {
    const touchHandler = (e) => {
        e.preventDefault(); // Prevent ghost clicks
        const keyValue = key.getAttribute('data-key');
        
        // Visual feedback
        key.style.background = 'var(--primary)';
        key.style.color = '#000';
        setTimeout(() => {
            key.style.background = '';
            key.style.color = '';
        }, 100);

        if (window.game && window.game.state === 'PLAYING') {
            window.game.handleKeyInput(keyValue);
        }
    };

    key.addEventListener('touchstart', touchHandler, {passive: false});
    key.addEventListener('mousedown', touchHandler); // For desktop testing
});

const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.15);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    },
    playExplosion() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    playKeystroke() {
        this.playTone(1200, 'sine', 0.05, 0.02);
    },
    playError() {
        this.playTone(150, 'sawtooth', 0.2, 0.05);
    }
};

const WORD_LIST = [
  "nepal","malai","ramro","lagchha","vector","laser","shield","plasma","orbit","space",
  "planet","meteor","rocket","alien","ufo","robot","cyborg","neon","pulse","matrix",
  "data","link","node","grid","flash","spark","blast","fire","storm","wind","rain",
  "thunder","light","dark","shadow","ghost","spirit","soul","mind","power","energy",
  "force","speed","agility","defense","attack","strike","guard","protect","save",
  "rescue","mission","command","control","system","network","server","client","proxy",
  "access","denied","allowed","secure","lock","key","cipher","code","hack","breach",
  "firewall","virus","malware","spyware","trojan","worm","botnet","root","kernel",
  "bash","script","python","java","rajesh","anil","parth","saroj","cloud","server",
  "database","query","select","insert","update","delete","compile","execute","render",
  "debug","deploy","commit","lama","pull","merge","branch","build","test","optimize",
  "thread","process","memory","cache","buffer","stream","packet","socket","router",
  "switch","gateway","domain","host","ping","trace","latency","bandwidth","signal",
  "sensor","camera","vision","audio","image","scalar","random","sample","filter",
  "noise","smooth","sharp","pixel","frame","motion","engine","driver","device",
  "screen","input","output","mouse","keyboard","touch","gesture","click","scroll",
  "zoom","pan",
  "love","you","string","number","boolean","null","undefined","function","method","class",
  "module","import","export","default","async","await","promise","callback","event","listener",
  "state","props","mount","unmount","effect","layout","theme","style","color","font",
  "border","margin","padding","radius","fonepay","layer","panel","window","dialog",
  "modal","alert","csd","prompt","toast","notify","message","status","success",
  "error","warning","info","retry","cancel","submit","reset","start","pause","resume",
  "stop","finish","score","level","stage","round","timer","clock","second","minute",
  "hour","day","night","dawn","dusk","sun","moon","star","galaxy","cosmos","comet",
  "asteroid","gravity","vacuum","beacon","radar","probe","drone","pilot","crew","fleet",
  "station","cargo","supply","fuel","thrust","angle","radius","circle","square","triangle",
  "polygon","point","line","plane","curve","slope","axis","origin","scale","ratio","factor",
  "value","limit","range","min","max","total","count","index","offset","length","width",
  "height","depth","volume","mass","weight","density","tempo","rhythm","pattern","cycle",
  "loop","repeat","break","continue","return","yield","throw","catch","try","finally",
  "check","verify","validate","sanitize","escape","encode","decode","encrypt","decrypt",
  "token","session","cookie","header","payload","request","response","route","path",
  "param","query","body","json","xml","yaml","text","binary","queue","stack","heap","tree",
  "graph","edge","vertex","weight","cost","pathway","bridge","tunnel","portal","gate",
  "door","keypad","button","toggle","slider","knob","lever","handle","grip","touchpad",
  "cursor","pointer","caret","select","focus","blur","hover","drag","drop","copy","paste",
  "cut","undo","redo","saveas","backup","restore","sync","share","publish","release",
  "version","patch","minor","major","stable","beta","legacy","modern","future","design",
  "model","schema","wireframe","mockup","prototype","draft","final","review","approve",
  "reject","conflict","resolve","history","tag","issue","ticket","bug","fix","hotfix",
  "crash","freeze","lag","delay","jitter","glitch","fault","monitor","metrics","profile",
  "benchmark","tune","refactor","cleanup","organize","format","lint","bundle","minify",
  "compress","prefetch","lazyload","repaint","reflow","animate","transition","transform",
  "rotate","translate","skew","tilt","center","align","justify","wrap","nowrap","truncate",
  "ellipsis","overflow","scrollbar","viewport","container","wrapper"
];

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        
        this.state = 'MENU';
        this.lastTime = 0;
        this.pauseTime = 0;
        
        this.spawnTimer = null;
        
        this.player = new Player(this);
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        
        this.score = 0;
        this.combo = 0;
        this.startTime = 0;
        this.wordsTyped = 0;
        this.totalKeystrokes = 0;
        this.missedKeystrokes = 0;
        this.difficultyMultiplier = 1;
        
        this.shake = 0;
        this.currentInput = ""; 

        this.resize();
        window.addEventListener('resize', () => this.resize());
        document.addEventListener('keydown', (e) => this.handleInput(e));
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.togglePause();
            }
        });

        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        this.player.y = this.height - 100; // Adjusted for mobile keyboard
        this.player.x = this.width / 2;
    }

    togglePause() {
        if (this.state === 'PLAYING') {
            this.state = 'PAUSED';
            this.pauseTime = performance.now();
            document.getElementById('pauseScreen').classList.remove('hidden');
            if (AudioSys.ctx) AudioSys.ctx.suspend();
            
            if (this.spawnTimer) {
                clearTimeout(this.spawnTimer);
                this.spawnTimer = null;
            }

        } else if (this.state === 'PAUSED') {
            this.state = 'PLAYING';
            document.getElementById('pauseScreen').classList.add('hidden');
            
            const pauseDuration = performance.now() - this.pauseTime;
            this.lastTime += pauseDuration;
            
            if (AudioSys.ctx) AudioSys.ctx.resume();
            
            this.spawnEnemy();
        }
    }

    start() {
        AudioSys.init();
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('pauseScreen').classList.add('hidden');
        
        this.reset();
        this.state = 'PLAYING';
        this.startTime = Date.now();
        this.lastTime = performance.now();
        this.spawnEnemy();
    }

    restart() {
        this.start();
    }

    reset() {
        if (this.spawnTimer) {
            clearTimeout(this.spawnTimer);
            this.spawnTimer = null;
        }

        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.score = 0;
        this.combo = 0;
        this.wordsTyped = 0;
        this.totalKeystrokes = 0;
        this.missedKeystrokes = 0;
        this.difficultyMultiplier = 1;
        this.currentInput = "";
        this.updateHUD();
        this.updateInputDisplay();
    }

    spawnEnemy() {
        if (this.state !== 'PLAYING') return;
        
        const word = WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)];
        const x = Math.random() * (this.width - 100) + 50;
        const y = -50;
        const speed = (Math.random() * 0.5 + 0.5) * this.difficultyMultiplier;
        const type = Math.random() > 0.8 ? 'ARMORED' : 'NORMAL';
        
        this.enemies.push(new Enemy(x, y, word, speed, type));
        
        const nextSpawn = Math.max(800, 2000 - (this.difficultyMultiplier * 200));
        
        this.spawnTimer = setTimeout(() => this.spawnEnemy(), nextSpawn);
    }

    // Unified Input Logic for Keyboard and Virtual Keys
    handleKeyInput(keyChar) {
        if (this.state !== 'PLAYING') return;
        
        // Handle Backspace
        if (keyChar === 'backspace') {
            if (this.currentInput.length > 0) {
                this.currentInput = this.currentInput.slice(0, -1);
                this.updateInputDisplay();
            }
            return;
        }

        // Handle Space
        if (keyChar === ' ') {
            this.spawnEnemy();
            this.createExplosion(this.width/2, 50, 'rgba(0,243,255,0.5)'); 
            return; 
        }
        
        // Handle Letters
        if (keyChar.length !== 1) return;
        const key = keyChar.toLowerCase();
        
        if (!/[a-z]/.test(key)) return;

        this.totalKeystrokes++;
        
        const prospectiveInput = this.currentInput + key;
        const matches = this.enemies.filter(enemy => enemy.word.startsWith(prospectiveInput));
        
        if (matches.length > 0) {
            const exactMatches = matches.filter(enemy => enemy.word === prospectiveInput);
            
            if (exactMatches.length > 0) {
                exactMatches.forEach(enemy => this.destroyEnemy(enemy));
                const remainingMatches = matches.filter(enemy => enemy.word !== prospectiveInput);
                this.currentInput = remainingMatches.length > 0 ? prospectiveInput : "";
            } else {
                this.currentInput = prospectiveInput;
                AudioSys.playKeystroke();
                matches.forEach(match => {
                    this.createBullet(this.player.x, this.player.y - 40, match.x, match.y);
                });
            }
            
        } else {
            this.missedKeystrokes++;
            this.breakCombo();
            AudioSys.playError();
            this.shake = 3;
        }
        
        this.updateHUD();
        this.updateInputDisplay();
    }

    handleInput(e) {
        // Wrapper for physical keyboard
        this.handleKeyInput(e.key);
    }

    destroyEnemy(enemy) {
        this.score += 10 * (1 + Math.floor(this.combo / 5)) * (enemy.type === 'ARMORED' ? 2 : 1);
        this.combo++;
        this.wordsTyped++;
        this.difficultyMultiplier += 0.02;
        
        AudioSys.playExplosion();
        this.createExplosion(enemy.x, enemy.y, enemy.type === 'ARMORED' ? '#ffaa00' : '#00f3ff');
        this.shake = 5;
        
        this.enemies = this.enemies.filter(e => e !== enemy);
        
        this.updateHUD();
        this.animateCombo();
    }

    breakCombo() {
        this.combo = 0;
        this.currentInput = ""; 
        this.updateInputDisplay();
    }

    createBullet(sx, sy, tx, ty) {
        AudioSys.playShoot();
        this.bullets.push(new Bullet(sx, sy, tx, ty));
    }

    createExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    updateInputDisplay() {
        const el = document.getElementById('inputBufferDisplay');
        if (!this.currentInput) {
            el.style.opacity = 0;
        } else {
            el.style.opacity = 0.8;
            el.innerHTML = this.currentInput;
            el.style.transform = "translateX(-50%) scale(1.1)";
            setTimeout(() => {
                el.style.transform = "translateX(-50%) scale(1)";
            }, 50);
        }
    }

    animateCombo() {
        const el = document.getElementById('comboDisplay');
        el.innerText = `COMBO x${this.combo}`;
        el.style.opacity = 1;
        el.style.transform = "scale(1.5)";
        setTimeout(() => {
            el.style.transform = "scale(1)";
            el.style.opacity = this.combo > 1 ? 1 : 0;
        }, 100);
    }

    updateHUD() {
        document.getElementById('scoreDisplay').innerText = this.score;
        document.getElementById('comboDisplay').innerText = `COMBO x${this.combo}`;
        
        const elapsedMin = (Date.now() - this.startTime) / 60000;
        const wpm = elapsedMin > 0 ? Math.floor((this.wordsTyped) / elapsedMin) : 0;
        document.getElementById('wpmDisplay').innerText = wpm;
    }

    async gameOver() {
        this.state = 'GAMEOVER';
        if (this.spawnTimer) {
            clearTimeout(this.spawnTimer);
            this.spawnTimer = null;
        }

        const elapsedMin = (Date.now() - this.startTime) / 60000;
        const finalWpm = elapsedMin > 0 ? Math.floor((this.wordsTyped) / elapsedMin) : 0;
        const accuracy = this.totalKeystrokes > 0 
            ? Math.floor(((this.totalKeystrokes - this.missedKeystrokes) / this.totalKeystrokes) * 100) 
            : 0;

        document.getElementById('finalScore').innerText = this.score;
        document.getElementById('finalWpm').innerText = finalWpm;
        document.getElementById('finalAcc').innerText = accuracy + '%';
        document.getElementById('finalWords').innerText = this.wordsTyped;
        
        document.getElementById('gameOverScreen').classList.remove('hidden');

        if (window.currentUser) {
            await saveScore(this.score, finalWpm);
        } else {
            console.log("User not logged in. Score not saved to leaderboard.");
        }
        
        loadLeaderboard('leaderboard-list');
    }

    loop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.ctx.fillStyle = 'rgba(5, 5, 16, 0.4)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.ctx.save();
        if (this.shake > 0) {
            const sx = (Math.random() - 0.5) * this.shake;
            const sy = (Math.random() - 0.5) * this.shake;
            this.ctx.translate(sx, sy);
            this.shake *= 0.9;
            if (this.shake < 0.5) this.shake = 0;
        }

        this.drawGrid();

        if (this.state === 'PLAYING') {
            this.player.update(dt);
            this.player.draw(this.ctx);

            const activeMatches = this.enemies.filter(e => 
                this.currentInput.length > 0 && e.word.startsWith(this.currentInput)
            );

            this.enemies.forEach((enemy, index) => {
                enemy.update(dt);
                const isMatch = activeMatches.includes(enemy);
                const isLocked = isMatch && activeMatches.length === 1; 
                enemy.draw(this.ctx, this.currentInput, isMatch, isLocked);
                
                if (enemy.y > this.height - 50) {
                    this.createExplosion(this.player.x, this.player.y, '#ff0000');
                    this.gameOver();
                }
            });

            this.bullets.forEach((b, i) => {
                b.update(dt);
                b.draw(this.ctx);
                if (b.life <= 0) this.bullets.splice(i, 1);
            });

            this.particles.forEach((p, i) => {
                p.update(dt);
                p.draw(this.ctx);
                if (p.life <= 0) this.particles.splice(i, 1);
            });

            if (activeMatches.length > 0) {
                activeMatches.forEach(target => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.player.x, this.player.y - 20);
                    this.ctx.lineTo(target.x, target.y);
                    this.ctx.strokeStyle = activeMatches.length === 1 
                        ? 'rgba(0, 243, 255, 0.4)' 
                        : 'rgba(0, 243, 255, 0.1)';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                });
            }
        } else if (this.state === 'PAUSED' || this.state === 'GAMEOVER' || this.state === 'MENU') {
            this.player.draw(this.ctx);

            const activeMatches = this.enemies.filter(e => 
                this.currentInput.length > 0 && e.word.startsWith(this.currentInput)
            );

            this.enemies.forEach((enemy) => {
                const isMatch = activeMatches.includes(enemy);
                const isLocked = isMatch && activeMatches.length === 1;
                enemy.draw(this.ctx, this.currentInput, isMatch, isLocked);
            });
            
            this.bullets.forEach((b) => b.draw(this.ctx));
            this.particles.forEach((p) => p.draw(this.ctx));
        }

        this.ctx.restore();
        requestAnimationFrame((t) => this.loop(t));
    }

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 243, 255, 0.1)';
        this.ctx.lineWidth = 1;
        for (let x = 0; x <= this.width; x += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.height);
            this.ctx.stroke();
        }
        const offset = (Date.now() / 50) % 50;
        for (let y = offset; y <= this.height; y += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.width, y);
            this.ctx.stroke();
        }
    }
}

class Player {
    constructor(game) {
        this.game = game;
        this.x = game.width / 2;
        this.y = game.height - 80;
        this.width = 50;
        this.height = 50;
    }

    update(dt) {
        this.y = this.game.height - 80 + Math.sin(Date.now() / 500) * 5;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.shadowBlur = 15;
        ctx.shadowColor = 'rgba(0, 243, 255, 0.5)';
        ctx.fillStyle = '#0a1a2a';
        ctx.beginPath();
        ctx.moveTo(0, -30);
        ctx.lineTo(20, 10);
        ctx.lineTo(30, 20);
        ctx.lineTo(-30, 20);
        ctx.lineTo(-20, 10);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#00f3ff';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#00f3ff';
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00f3ff';
        ctx.fillStyle = 'rgba(0, 243, 255, 0.8)';
        ctx.beginPath();
        ctx.moveTo(-10, 20);
        ctx.lineTo(0, 35 + Math.random() * 10);
        ctx.lineTo(10, 20);
        ctx.fill();
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, word, speed, type) {
        this.x = x;
        this.y = y;
        this.word = word;
        this.type = type;
        this.speed = speed;
        this.wobbleOffset = Math.random() * Math.PI * 2;
    }

    update(dt) {
        this.y += this.speed;
        this.wobbleOffset += dt * 2;
    }

    draw(ctx, inputBuffer, isMatch, isLocked) {
        ctx.save();
        ctx.translate(this.x + (Math.sin(this.wobbleOffset) * 5), this.y);

        let baseColor = '#ffffff';
        let glowColor = 'rgba(255, 255, 255, 0.2)';
        
        if (this.type === 'ARMORED') {
            baseColor = '#ffaa00';
            glowColor = 'rgba(255, 170, 0, 0.2)';
        }

        if (isMatch) {
            if (isLocked) {
                baseColor = '#ff0055'; 
                glowColor = 'rgba(255, 0, 85, 0.4)';
            } else {
                baseColor = '#00f3ff'; 
                glowColor = 'rgba(0, 243, 255, 0.4)';
            }
        }

        ctx.shadowBlur = isMatch ? 20 : 10;
        ctx.shadowColor = baseColor;
        
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';

        ctx.beginPath();
        if (this.type === 'ARMORED') {
            ctx.moveTo(0, 20);
            ctx.lineTo(15, -10);
            ctx.lineTo(25, 0); 
            ctx.lineTo(15, 10);
            ctx.lineTo(-15, 10);
            ctx.lineTo(-25, 0);
            ctx.lineTo(-15, -10);
        } else {
            ctx.moveTo(0, 25);
            ctx.lineTo(10, -5);
            ctx.lineTo(20, -10);
            ctx.lineTo(0, -5); 
            ctx.lineTo(-20, -10);
            ctx.lineTo(-10, -5);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        if (isLocked) {
            ctx.beginPath();
            ctx.strokeStyle = '#ff0055';
            ctx.lineWidth = 1;
            ctx.arc(0, 5, 35, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(-5, 40);
            ctx.lineTo(5, 40);
            ctx.lineTo(0, 50);
            ctx.fillStyle = '#ff0055';
            ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.font = 'bold 20px "Roboto Mono"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const matchIndex = inputBuffer.length;
        
        const typedPart = this.word.substring(0, matchIndex);
        const remainPart = this.word.substring(matchIndex);
        
        const totalWidth = ctx.measureText(this.word).width;
        const startX = -totalWidth / 2;

        if (isMatch && matchIndex > 0) {
            ctx.fillStyle = 'rgba(0, 255, 102, 0.9)';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff66';
            ctx.fillText(typedPart, startX + ctx.measureText(typedPart).width/2, -30);
            ctx.shadowBlur = 0;
        } else if (!isMatch && matchIndex > 0) {
            ctx.fillStyle = '#555';
            ctx.fillText(this.word, startX + totalWidth/2, -30);
        } else {
            ctx.fillStyle = '#fff';
            ctx.fillText(this.word, startX + totalWidth/2, -30);
        }

        if (isMatch && remainPart.length > 0) {
            ctx.fillStyle = isLocked ? '#ff0055' : '#fff';
            ctx.fillText(remainPart, startX + ctx.measureText(typedPart).width + ctx.measureText(remainPart).width/2, -30);
        }

        ctx.restore();
    }
}

class Bullet {
    constructor(sx, sy, tx, ty) {
        this.x = sx;
        this.y = sy;
        this.tx = tx;
        this.ty = ty;
        this.speed = 1200; 
        const angle = Math.atan2(ty - sy, tx - sx);
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.life = 1.0;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        const dist = Math.hypot(this.x - this.tx, this.y - this.ty);
        if (dist < 50) this.life = 0; 
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        ctx.fillStyle = '#00f3ff';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00f3ff';
        ctx.beginPath();
        ctx.rect(-10, -2, 20, 4);
        ctx.fill();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 100 + 50;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const game = new Game();

</script>
</body>
</html>
