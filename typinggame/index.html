<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Tags for Google and Social Media -->
    <title>Typing Defender - Free 3D Typing Shooter Game</title>
    <meta name="description" content="Play Typing Defender, a free 3D typing shooter game. Improve your WPM and accuracy while defending system from cyber enemies in a neon retro-future world.">
    <meta name="keywords" content="typing game, shooter game, WPM game, HTML5 game, browser game, educational game, cyberpunk, neon, free online game">
    <meta name="author" content="Anil Lama">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://anillama.com.np/typinggame/">
    <meta property="og:title" content="Typing Defender - 3D Typing Shooter">
    <meta property="og:description" content="Type to destroy incoming enemies. Test your typing speed in this intense arcade experience.">
    
    <script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyCNVdBXRTJMkACc46EUmn38Vy4Flz3vDOQ",
    authDomain: "typing-game-c5e84.firebaseapp.com",
    projectId: "typing-game-c5e84",
    storageBucket: "typing-game-c5e84.firebasestorage.app",
    messagingSenderId: "1017813191155",
    appId: "1:1017813191155:web:af354c72711c6488562a86"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
</script>
       <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --primary: #00f3ff;
            --danger: #ff0055;
            --success: #00ff66;
            --bg: #050510;
            --ui-font: 'Orbitron', sans-serif;
            --type-font: 'Roboto Mono', monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            color: white;
            font-family: var(--ui-font);
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            text-shadow: 0 0 10px var(--primary);
        }

        .hud-stat {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 1px solid var(--primary);
            border-radius: 4px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }

        .hud-stat span {
            color: var(--primary);
            font-weight: bold;
        }

        .hud-combo {
            text-align: center;
            color: var(--success);
            font-size: 1.5rem;
            text-shadow: 0 0 20px var(--success);
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
        }

        /* Current Input Display (shows what you are typing) */
        .current-input {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-family: var(--type-font);
            font-size: 2rem;
            color: var(--primary);
            text-shadow: 0 0 10px var(--primary);
            letter-spacing: 5px;
            opacity: 0.8;
            pointer-events: none;
            transition: transform 0.1s;
        }
        
        .current-input span {
            color: #fff;
            background: var(--danger);
            padding: 0 5px;
            border-radius: 4px;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 5px;
            filter: drop-shadow(0 0 15px var(--primary));
            text-align: center;
        }

        h2 {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 5px var(--primary);
            font-weight: 400;
        }

        p.subtitle {
            font-family: var(--type-font);
            color: #aaa;
            font-size: 1.2rem;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
        }

        .btn {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: var(--ui-font);
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            pointer-events: auto;
        }

        .btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 30px var(--primary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
            text-align: left;
        }

        .stat-box {
            border-left: 4px solid var(--danger);
            padding-left: 15px;
        }
        
        .stat-label { font-size: 0.8rem; color: #888; }
        .stat-value { font-size: 1.5rem; font-weight: bold; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Visual Input Buffer -->
    <div class="current-input" id="inputBufferDisplay"></div>

    <div class="ui-layer" id="hud">
        <div class="hud-top">
            <div class="hud-stat">SCORE: <span id="scoreDisplay">0</span></div>
            <div class="hud-stat">WPM: <span id="wpmDisplay">0</span></div>
        </div>
        <div class="hud-combo" id="comboDisplay">COMBO x1</div>
    </div>

    <!-- START SCREEN -->
    <div class="modal" id="startScreen">
        <h1>TYPING DEFENDER</h1>
        <h2>BY ANIL LAMA</h2>
        <p class="subtitle">Type words to destroy enemies.<br>
        <strong>SMART TARGETING:</strong> If multiple words start the same (e.g. "select" & "server"), type until they differ to lock the correct one. <br>
        Typing a wrong letter resets your combo.<br>
        <strong>FEATURE:</strong> Press SPACE to spawn extra enemies instantly.<br>
        Press ESC to Pause.</p>
        <button class="btn" onclick="game.start()">START GAME</button>
        <button onclick="loginWithGoogle()">Login with Gmail</button>
    </div>

    <!-- PAUSE SCREEN -->
    <div class="modal hidden" id="pauseScreen">
        <h1>GAME PAUSED</h1>
        <h2>Game Rokyo!!</h2>
        <button class="btn" onclick="game.togglePause()">RESUME</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div class="modal hidden" id="gameOverScreen">
        <h1 style="color: var(--danger); -webkit-text-fill-color: var(--danger);">GAME OVER</h1>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">FINAL SCORE</div>
                <div class="stat-value" id="finalScore">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">MAX WPM</div>
                <div class="stat-value" id="finalWpm">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ACCURACY</div>
                <div class="stat-value" id="finalAcc">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">WORDS DESTROYED</div>
                <div class="stat-value" id="finalWords">0</div>
            </div>
        </div>
        <button class="btn" onclick="game.restart()">TRY AGAIN</button>
    </div>
</div>

<script>
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.15);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    },
    playExplosion() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    playKeystroke() {
        this.playTone(1200, 'sine', 0.05, 0.02);
    },
    playError() {
        this.playTone(150, 'sawtooth', 0.2, 0.05);
    }
};

const WORD_LIST = [
  "shell","alpha","bravo","target","vector","laser","shield","plasma","orbit","space",
  "planet","meteor","rocket","alien","ufo","robot","cyborg","neon","pulse","matrix",
  "data","link","node","grid","flash","spark","blast","fire","storm","wind","rain",
  "thunder","light","dark","shadow","ghost","spirit","soul","mind","power","energy",
  "force","speed","agility","defense","attack","strike","guard","protect","save",
  "rescue","mission","command","control","system","network","server","client","proxy",
  "access","denied","allowed","secure","lock","key","cipher","code","hack","breach",
  "firewall","virus","malware","spyware","trojan","worm","botnet","root","kernel",
  "bash","script","python","java","rajesh","anil","parth","saroj","cloud","server",
  "database","query","select","insert","update","delete","compile","execute","render",
  "debug","deploy","commit","lama","pull","merge","branch","build","test","optimize",
  "thread","process","memory","cache","buffer","stream","packet","socket","router",
  "switch","gateway","domain","host","ping","trace","latency","bandwidth","signal",
  "sensor","camera","vision","audio","image","scalar","random","sample","filter",
  "noise","smooth","sharp","pixel","frame","motion","engine","driver","device",
  "screen","input","output","mouse","keyboard","touch","gesture","click","scroll",
  "zoom","pan",
  "array","object","string","number","boolean","null","undefined","function","method","class",
  "module","import","export","default","async","await","promise","callback","event","listener",
  "state","props","mount","unmount","effect","layout","theme","style","color","font",
  "border","margin","padding","radius","fonepay","layer","panel","window","dialog",
  "modal","alert","csd","prompt","toast","notify","message","status","success",
  "error","warning","info","retry","cancel","submit","reset","start","pause","resume",
  "stop","finish","score","level","stage","round","timer","clock","second","minute",
  "hour","day","night","dawn","dusk","sun","moon","star","galaxy","cosmos","comet",
  "asteroid","gravity","vacuum","beacon","radar","probe","drone","pilot","crew","fleet",
  "station","cargo","supply","fuel","thrust","angle","radius","circle","square","triangle",
  "polygon","point","line","plane","curve","slope","axis","origin","scale","ratio","factor",
  "value","limit","range","min","max","total","count","index","offset","length","width",
  "height","depth","volume","mass","weight","density","tempo","rhythm","pattern","cycle",
  "loop","repeat","break","continue","return","yield","throw","catch","try","finally",
  "check","verify","validate","sanitize","escape","encode","decode","encrypt","decrypt",
  "token","session","cookie","header","payload","request","response","route","path",
  "param","query","body","json","xml","yaml","text","binary","queue","stack","heap","tree",
  "graph","edge","vertex","weight","cost","pathway","bridge","tunnel","portal","gate",
  "door","keypad","button","toggle","slider","knob","lever","handle","grip","touchpad",
  "cursor","pointer","caret","select","focus","blur","hover","drag","drop","copy","paste",
  "cut","undo","redo","saveas","backup","restore","sync","share","publish","release",
  "version","patch","minor","major","stable","beta","legacy","modern","future","design",
  "model","schema","wireframe","mockup","prototype","draft","final","review","approve",
  "reject","conflict","resolve","history","tag","issue","ticket","bug","fix","hotfix",
  "crash","freeze","lag","delay","jitter","glitch","fault","monitor","metrics","profile",
  "benchmark","tune","refactor","cleanup","organize","format","lint","bundle","minify",
  "compress","prefetch","lazyload","repaint","reflow","animate","transition","transform",
  "rotate","translate","skew","tilt","center","align","justify","wrap","nowrap","truncate",
  "ellipsis","overflow","scrollbar","viewport","container","wrapper"
];

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        
        this.state = 'MENU';
        this.lastTime = 0;
        this.pauseTime = 0;
        
        // Store spawn timer ID to control it on Pause/Resume
        this.spawnTimer = null;
        
        this.player = new Player(this);
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        
        this.score = 0;
        this.combo = 0;
        this.startTime = 0;
        this.wordsTyped = 0;
        this.totalKeystrokes = 0;
        this.missedKeystrokes = 0;
        this.difficultyMultiplier = 1;
        
        this.shake = 0;
        
        // Global Input Buffer
        this.currentInput = ""; 

        this.resize();
        window.addEventListener('resize', () => this.resize());
        document.addEventListener('keydown', (e) => this.handleInput(e));
        
        // Pause Listener - ONLY ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.togglePause();
            }
        });

        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        this.player.y = this.height - 80;
        this.player.x = this.width / 2;
    }

    togglePause() {
        if (this.state === 'PLAYING') {
            // PAUSE
            this.state = 'PAUSED';
            this.pauseTime = performance.now();
            document.getElementById('pauseScreen').classList.remove('hidden');
            if (AudioSys.ctx) AudioSys.ctx.suspend();
            
            // STOP the spawn timer
            if (this.spawnTimer) {
                clearTimeout(this.spawnTimer);
                this.spawnTimer = null;
            }

        } else if (this.state === 'PAUSED') {
            // RESUME
            this.state = 'PLAYING';
            document.getElementById('pauseScreen').classList.add('hidden');
            
            // Adjust lastTime to account for time spent paused
            const pauseDuration = performance.now() - this.pauseTime;
            this.lastTime += pauseDuration;
            
            if (AudioSys.ctx) AudioSys.ctx.resume();
            
            // RESTART the spawn timer
            this.spawnEnemy();
        }
    }

    start() {
        AudioSys.init();
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('pauseScreen').classList.add('hidden');
        
        this.reset();
        this.state = 'PLAYING';
        this.startTime = Date.now();
        this.lastTime = performance.now();
        this.spawnEnemy();
    }

    restart() {
        this.start();
    }

    reset() {
        // Clear spawn timer if restarting
        if (this.spawnTimer) {
            clearTimeout(this.spawnTimer);
            this.spawnTimer = null;
        }

        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.score = 0;
        this.combo = 0;
        this.wordsTyped = 0;
        this.totalKeystrokes = 0;
        this.missedKeystrokes = 0;
        this.difficultyMultiplier = 1;
        this.currentInput = "";
        this.updateHUD();
        this.updateInputDisplay();
    }

    spawnEnemy() {
        // If we are not playing, stop the chain (unless it's a temp pause)
        if (this.state !== 'PLAYING') return;
        
        const word = WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)];
        const x = Math.random() * (this.width - 150) + 75;
        const y = -50;
        const speed = (Math.random() * 0.5 + 0.5) * this.difficultyMultiplier;
        const type = Math.random() > 0.8 ? 'ARMORED' : 'NORMAL';
        
        this.enemies.push(new Enemy(x, y, word, speed, type));
        
        const nextSpawn = Math.max(800, 2000 - (this.difficultyMultiplier * 200));
        
        // Store the timer ID so we can clear it on Pause
        this.spawnTimer = setTimeout(() => this.spawnEnemy(), nextSpawn);
    }

    handleInput(e) {
        if (this.state !== 'PLAYING') return;
        
        // Special Feature: Press Space to Spawn Extra Enemy
        if (e.code === 'Space' || e.key === ' ') {
            e.preventDefault(); // Stop scrolling
            this.spawnEnemy();
            // Optional: Visual flash to confirm spawn
            this.createExplosion(this.width/2, 50, 'rgba(0,243,255,0.5)'); 
            return; 
        }
        
        // Allow only single characters (letters), ignore control keys unless specified
        if (e.key.length !== 1) return;
        const key = e.key.toLowerCase();
        
        // Only accept letters
        if (!/[a-z]/.test(key)) return;

        this.totalKeystrokes++;
        
        // 1. Create prospective new input string
        const prospectiveInput = this.currentInput + key;
        
        // 2. Find all enemies that START WITH this prospective input
        const matches = this.enemies.filter(enemy => enemy.word.startsWith(prospectiveInput));
        
        if (matches.length > 0) {
            // VALID KEYSTROKE
            
            // Check for exact matches (destruction)
            const exactMatches = matches.filter(enemy => enemy.word === prospectiveInput);
            
            if (exactMatches.length > 0) {
                // Destroy all exact matches
                exactMatches.forEach(enemy => this.destroyEnemy(enemy));
                // If there are still partial matches (e.g. two "select" words), keep buffer, else clear
                const remainingMatches = matches.filter(enemy => enemy.word !== prospectiveInput);
                this.currentInput = remainingMatches.length > 0 ? prospectiveInput : "";
            } else {
                // Partial matches only (Ambiguity or continuing a word)
                
                this.currentInput = prospectiveInput;
                AudioSys.playKeystroke();
                
                // Visual feedback: Shoot at ALL matching enemies (cool factor)
                matches.forEach(match => {
                    this.createBullet(this.player.x, this.player.y - 40, match.x, match.y);
                });
            }
            
        } else {
            // INVALID KEYSTROKE
            this.missedKeystrokes++;
            this.breakCombo();
            AudioSys.playError();
            
            // Optional: Shake screen on error
            this.shake = 3;
        }
        
        this.updateHUD();
        this.updateInputDisplay();
    }

    destroyEnemy(enemy) {
        this.score += 10 * (1 + Math.floor(this.combo / 5)) * (enemy.type === 'ARMORED' ? 2 : 1);
        this.combo++;
        this.wordsTyped++;
        this.difficultyMultiplier += 0.02;
        
        AudioSys.playExplosion();
        this.createExplosion(enemy.x, enemy.y, enemy.type === 'ARMORED' ? '#ffaa00' : '#00f3ff');
        this.shake = 5;
        
        this.enemies = this.enemies.filter(e => e !== enemy);
        
        this.updateHUD();
        this.animateCombo();
    }

    breakCombo() {
        this.combo = 0;
        this.currentInput = ""; // Reset input on error
        this.updateInputDisplay();
    }

    createBullet(sx, sy, tx, ty) {
        AudioSys.playShoot();
        this.bullets.push(new Bullet(sx, sy, tx, ty));
    }

    createExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    updateInputDisplay() {
        const el = document.getElementById('inputBufferDisplay');
        if (!this.currentInput) {
            el.style.opacity = 0;
        } else {
            el.style.opacity = 0.8;
            // Highlight typed part
            el.innerHTML = this.currentInput;
            el.style.transform = "translateX(-50%) scale(1.1)";
            setTimeout(() => {
                el.style.transform = "translateX(-50%) scale(1)";
            }, 50);
        }
    }

    animateCombo() {
        const el = document.getElementById('comboDisplay');
        el.innerText = `COMBO x${this.combo}`;
        el.style.opacity = 1;
        el.style.transform = "scale(1.5)";
        setTimeout(() => {
            el.style.transform = "scale(1)";
            el.style.opacity = this.combo > 1 ? 1 : 0;
        }, 100);
    }

    updateHUD() {
        document.getElementById('scoreDisplay').innerText = this.score;
        document.getElementById('comboDisplay').innerText = `COMBO x${this.combo}`;
        
        const elapsedMin = (Date.now() - this.startTime) / 60000;
        const wpm = elapsedMin > 0 ? Math.floor((this.wordsTyped) / elapsedMin) : 0;
        document.getElementById('wpmDisplay').innerText = wpm;
    }

    gameOver() {
        this.state = 'GAMEOVER';
        // Clear spawn timer on game over
        if (this.spawnTimer) {
            clearTimeout(this.spawnTimer);
            this.spawnTimer = null;
        }

        const elapsedMin = (Date.now() - this.startTime) / 60000;
        const finalWpm = elapsedMin > 0 ? Math.floor((this.wordsTyped) / elapsedMin) : 0;
        const accuracy = this.totalKeystrokes > 0 
            ? Math.floor(((this.totalKeystrokes - this.missedKeystrokes) / this.totalKeystrokes) * 100) 
            : 0;

        document.getElementById('finalScore').innerText = this.score;
        document.getElementById('finalWpm').innerText = finalWpm;
        document.getElementById('finalAcc').innerText = accuracy + '%';
        document.getElementById('finalWords').innerText = this.wordsTyped;
        
        document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    loop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.ctx.fillStyle = 'rgba(5, 5, 16, 0.4)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.ctx.save();
        if (this.shake > 0) {
            const sx = (Math.random() - 0.5) * this.shake;
            const sy = (Math.random() - 0.5) * this.shake;
            this.ctx.translate(sx, sy);
            this.shake *= 0.9;
            if (this.shake < 0.5) this.shake = 0;
        }

        this.drawGrid();

        // Only run update logic if playing
        if (this.state === 'PLAYING') {
            this.player.update(dt);
            this.player.draw(this.ctx);

            // Determine matches based on current buffer
            const activeMatches = this.enemies.filter(e => 
                this.currentInput.length > 0 && e.word.startsWith(this.currentInput)
            );

            this.enemies.forEach((enemy, index) => {
                enemy.update(dt);
                // Pass currentInput to draw to handle highlighting logic
                const isMatch = activeMatches.includes(enemy);
                const isLocked = isMatch && activeMatches.length === 1; // Only lock visually if unique
                enemy.draw(this.ctx, this.currentInput, isMatch, isLocked);
                
                if (enemy.y > this.height - 50) {
                    this.createExplosion(this.player.x, this.player.y, '#ff0000');
                    this.gameOver();
                }
            });

            this.bullets.forEach((b, i) => {
                b.update(dt);
                b.draw(this.ctx);
                if (b.life <= 0) this.bullets.splice(i, 1);
            });

            this.particles.forEach((p, i) => {
                p.update(dt);
                p.draw(this.ctx);
                if (p.life <= 0) this.particles.splice(i, 1);
            });

            // Draw targeting lines to all active matches
            if (activeMatches.length > 0) {
                activeMatches.forEach(target => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.player.x, this.player.y - 20);
                    this.ctx.lineTo(target.x, target.y);
                    // If unique match, solid line. If multiple, faint dashed line.
                    this.ctx.strokeStyle = activeMatches.length === 1 
                        ? 'rgba(0, 243, 255, 0.4)' 
                        : 'rgba(0, 243, 255, 0.1)';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                });
            }
        } else if (this.state === 'PAUSED' || this.state === 'GAMEOVER' || this.state === 'MENU') {
            // If not playing (paused, game over, menu), we still draw entities
            // but we don't call update() so they stay frozen in place
            this.player.draw(this.ctx);

            // Determine matches based on current buffer (needed for draw)
            const activeMatches = this.enemies.filter(e => 
                this.currentInput.length > 0 && e.word.startsWith(this.currentInput)
            );

            this.enemies.forEach((enemy) => {
                const isMatch = activeMatches.includes(enemy);
                const isLocked = isMatch && activeMatches.length === 1;
                enemy.draw(this.ctx, this.currentInput, isMatch, isLocked);
            });
            
            this.bullets.forEach((b) => b.draw(this.ctx));
            this.particles.forEach((p) => p.draw(this.ctx));
        }

        this.ctx.restore();
        requestAnimationFrame((t) => this.loop(t));
    }

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 243, 255, 0.1)';
        this.ctx.lineWidth = 1;
        for (let x = 0; x <= this.width; x += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.height);
            this.ctx.stroke();
        }
        const offset = (Date.now() / 50) % 50;
        for (let y = offset; y <= this.height; y += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.width, y);
            this.ctx.stroke();
        }
    }
}

class Player {
    constructor(game) {
        this.game = game;
        this.x = game.width / 2;
        this.y = game.height - 80;
        this.width = 50;
        this.height = 50;
    }

    update(dt) {
        this.y = this.game.height - 80 + Math.sin(Date.now() / 500) * 5;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.shadowBlur = 15;
        ctx.shadowColor = 'rgba(0, 243, 255, 0.5)';
        ctx.fillStyle = '#0a1a2a';
        ctx.beginPath();
        ctx.moveTo(0, -30);
        ctx.lineTo(20, 10);
        ctx.lineTo(30, 20);
        ctx.lineTo(-30, 20);
        ctx.lineTo(-20, 10);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#00f3ff';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#00f3ff';
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00f3ff';
        ctx.fillStyle = 'rgba(0, 243, 255, 0.8)';
        ctx.beginPath();
        ctx.moveTo(-10, 20);
        ctx.lineTo(0, 35 + Math.random() * 10);
        ctx.lineTo(10, 20);
        ctx.fill();
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, word, speed, type) {
        this.x = x;
        this.y = y;
        this.word = word;
        this.type = type;
        this.speed = speed;
        this.wobbleOffset = Math.random() * Math.PI * 2;
    }

    update(dt) {
        this.y += this.speed;
        this.wobbleOffset += dt * 2;
    }

    draw(ctx, inputBuffer, isMatch, isLocked) {
        ctx.save();
        ctx.translate(this.x + (Math.sin(this.wobbleOffset) * 5), this.y);

        // Determine Color
        let baseColor = '#ffffff';
        let glowColor = 'rgba(255, 255, 255, 0.2)';
        
        if (this.type === 'ARMORED') {
            baseColor = '#ffaa00';
            glowColor = 'rgba(255, 170, 0, 0.2)';
        }

        if (isMatch) {
            if (isLocked) {
                baseColor = '#ff0055'; // Red when locked uniquely
                glowColor = 'rgba(255, 0, 85, 0.4)';
            } else {
                baseColor = '#00f3ff'; // Cyan when multiple match (Ambiguous)
                glowColor = 'rgba(0, 243, 255, 0.4)';
            }
        }

        ctx.shadowBlur = isMatch ? 20 : 10;
        ctx.shadowColor = baseColor;
        
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';

        ctx.beginPath();
        if (this.type === 'ARMORED') {
            ctx.moveTo(0, 20);
            ctx.lineTo(15, -10);
            ctx.lineTo(25, 0); 
            ctx.lineTo(15, 10);
            ctx.lineTo(-15, 10);
            ctx.lineTo(-25, 0);
            ctx.lineTo(-15, -10);
        } else {
            ctx.moveTo(0, 25);
            ctx.lineTo(10, -5);
            ctx.lineTo(20, -10);
            ctx.lineTo(0, -5); 
            ctx.lineTo(-20, -10);
            ctx.lineTo(-10, -5);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw Lock Circle
        if (isLocked) {
            ctx.beginPath();
            ctx.strokeStyle = '#ff0055';
            ctx.lineWidth = 1;
            ctx.arc(0, 5, 35, 0, Math.PI * 2);
            ctx.stroke();
            
            // Down arrow indicator
            ctx.beginPath();
            ctx.moveTo(-5, 40);
            ctx.lineTo(5, 40);
            ctx.lineTo(0, 50);
            ctx.fillStyle = '#ff0055';
            ctx.fill();
        }

        // Draw Text
        ctx.shadowBlur = 0;
        ctx.font = 'bold 20px "Roboto Mono"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Logic: Split word into "Typed" (matches input) and "Remaining"
        const matchIndex = inputBuffer.length;
        
        const typedPart = this.word.substring(0, matchIndex);
        const remainPart = this.word.substring(matchIndex);
        
        const totalWidth = ctx.measureText(this.word).width;
        const startX = -totalWidth / 2;

        // Render Typed Part (Green/Highlighted)
        if (isMatch && matchIndex > 0) {
            ctx.fillStyle = 'rgba(0, 255, 102, 0.9)';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff66';
            ctx.fillText(typedPart, startX + ctx.measureText(typedPart).width/2, -30);
            ctx.shadowBlur = 0;
        } else if (!isMatch && matchIndex > 0) {
            // If we have input but this enemy ISN'T a match (the other bug case)
            // Render the word dimmed or normal
            ctx.fillStyle = '#555';
            ctx.fillText(this.word, startX + totalWidth/2, -30);
        } else {
            // Completely un-typed
            ctx.fillStyle = '#fff';
            ctx.fillText(this.word, startX + totalWidth/2, -30);
        }

        // Render Remaining Part
        if (isMatch && remainPart.length > 0) {
            ctx.fillStyle = isLocked ? '#ff0055' : '#fff';
            ctx.fillText(remainPart, startX + ctx.measureText(typedPart).width + ctx.measureText(remainPart).width/2, -30);
        }

        ctx.restore();
    }
}

class Bullet {
    constructor(sx, sy, tx, ty) {
        this.x = sx;
        this.y = sy;
        this.tx = tx;
        this.ty = ty;
        this.speed = 1200; 
        const angle = Math.atan2(ty - sy, tx - sx);
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.life = 1.0;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        const dist = Math.hypot(this.x - this.tx, this.y - this.ty);
        if (dist < 50) this.life = 0; 
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        ctx.fillStyle = '#00f3ff';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00f3ff';
        ctx.beginPath();
        ctx.rect(-10, -2, 20, 4);
        ctx.fill();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 100 + 50;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const game = new Game();

</script>
</body>
</html>
