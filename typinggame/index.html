<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Type Defender - 3D Typing Shooter</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --primary: #00f3ff;
            --danger: #ff0055;
            --success: #00ff66;
            --bg: #050510;
            --ui-font: 'Orbitron', sans-serif;
            --type-font: 'Roboto Mono', monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            color: white;
            font-family: var(--ui-font);
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            text-shadow: 0 0 10px var(--primary);
        }

        .hud-stat {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 1px solid var(--primary);
            border-radius: 4px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }

        .hud-stat span {
            color: var(--primary);
            font-weight: bold;
        }

        .hud-combo {
            text-align: center;
            color: var(--success);
            font-size: 1.5rem;
            text-shadow: 0 0 20px var(--success);
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 5px;
            filter: drop-shadow(0 0 15px var(--primary));
            text-align: center;
        }

        p.subtitle {
            font-family: var(--type-font);
            color: #aaa;
            font-size: 1.2rem;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
        }

        .btn {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: var(--ui-font);
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 30px var(--primary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
            text-align: left;
        }

        .stat-box {
            border-left: 4px solid var(--danger);
            padding-left: 15px;
        }
        
        .stat-label { font-size: 0.8rem; color: #888; }
        .stat-value { font-size: 1.5rem; font-weight: bold; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer" id="hud">
        <div class="hud-top">
            <div class="hud-stat">SCORE: <span id="scoreDisplay">0</span></div>
            <div class="hud-stat">WPM: <span id="wpmDisplay">0</span></div>
        </div>
        <div class="hud-combo" id="comboDisplay">COMBO x1</div>
    </div>

    <div class="modal" id="startScreen">
        <h1>NEO	N DEFENDER</h1>
<h2>ANIL LAMA</h2>
        <p class="subtitle">Type the words to destroy enemies.<br>Typing a wrong letter resets the word.</p>
        <button class="btn" onclick="game.start()">START</button>
    </div>

    <div class="modal hidden" id="gameOverScreen">
        <h1 style="color: var(--danger); -webkit-text-fill-color: var(--danger);">MISSION FAILED</h1>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">FINAL SCORE</div>
                <div class="stat-value" id="finalScore">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">MAX WPM</div>
                <div class="stat-value" id="finalWpm">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ACCURACY</div>
                <div class="stat-value" id="finalAcc">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">WORDS DESTROYED</div>
                <div class="stat-value" id="finalWords">0</div>
            </div>
        </div>
        <button class="btn" onclick="game.restart()">Reboot System</button>
    </div>
</div>

<script>
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.15);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    },
    playExplosion() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    playKeystroke() {
        this.playTone(1200, 'sine', 0.05, 0.02);
    },
    playError() {
        this.playTone(150, 'sawtooth', 0.2, 0.05);
    }
};

const WORD_LIST = [
    "shell", "alpha", "bravo", "target", "vector", "laser", "shield", "plasma", "orbit", 
    "space", "planet", "meteor", "rocket", "alien", "ufo", "robot", "cyborg",
    "neon", "pulse", "matrix", "data", "link", "node", "grid", "flash", "spark",
    "blast", "fire", "storm", "wind", "rain", "thunder", "light", "dark", "shadow",
    "ghost", "spirit", "soul", "mind", "power", "energy", "force", "speed", "agility",
    "defense", "attack", "strike", "guard", "protect", "save", "rescue", "mission",
    "command", "control", "system", "network", "server", "client", "proxy", "access",
    "denied", "allowed", "secure", "lock", "key", "cipher", "code", "hack", "breach",
    "firewall", "virus", "malware", "spyware", "trojan", "worm", "botnet", "root",
    "kernel", "shell", "bash", "script", "python", "java", "html", "css", "web",
    "internet", "cloud", "server", "database", "query", "select", "insert", "update"
];

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        
        this.state = 'MENU';
        this.lastTime = 0;
        
        this.player = new Player(this);
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        
        this.score = 0;
        this.combo = 0;
        this.startTime = 0;
        this.wordsTyped = 0;
        this.totalKeystrokes = 0;
        this.missedKeystrokes = 0;
        this.difficultyMultiplier = 1;
        
        this.shake = 0;
        this.targetEnemy = null;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        document.addEventListener('keydown', (e) => this.handleInput(e));
        
        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        this.player.y = this.height - 80;
        this.player.x = this.width / 2;
    }

    start() {
        AudioSys.init();
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        
        this.reset();
        this.state = 'PLAYING';
        this.startTime = Date.now();
        this.spawnEnemy();
    }

    restart() {
        this.start();
    }

    reset() {
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.score = 0;
        this.combo = 0;
        this.wordsTyped = 0;
        this.totalKeystrokes = 0;
        this.missedKeystrokes = 0;
        this.difficultyMultiplier = 1;
        this.targetEnemy = null;
        this.updateHUD();
    }

    spawnEnemy() {
        if (this.state !== 'PLAYING') return;
        
        const word = WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)];
        const x = Math.random() * (this.width - 150) + 75;
        const y = -50;
        const speed = (Math.random() * 0.5 + 0.5) * this.difficultyMultiplier;
        const type = Math.random() > 0.8 ? 'ARMORED' : 'NORMAL';
        
        this.enemies.push(new Enemy(x, y, word, speed, type));
        
        const nextSpawn = Math.max(800, 2000 - (this.difficultyMultiplier * 200));
        setTimeout(() => this.spawnEnemy(), nextSpawn);
    }

    handleInput(e) {
        if (this.state !== 'PLAYING') return;
        
        if (e.key.length > 1 && e.key !== 'Backspace' && e.key !== 'Enter') return;
        
        const key = e.key.toLowerCase();
        this.totalKeystrokes++;
        
        let handled = false;

        // 1. If we have a locked target, strictly check the next character
        if (this.targetEnemy && this.enemies.includes(this.targetEnemy)) {
            const nextChar = this.targetEnemy.word[this.targetEnemy.typedIndex];
            
            if (key === nextChar) {
                this.processCorrectHit(this.targetEnemy);
                handled = true;
            } else {
                // Typo on locked target: Reset everything for strictness
                this.missedKeystrokes++;
                this.breakCombo();
                AudioSys.playError();
                this.createFloatingText(this.targetEnemy.x, this.targetEnemy.y - 20, "RESET", "red");
                handled = true;
            }
        } else {
            // 2. No target locked: Find a new word starting with this key
            // We only lock words that are fully reset (typedIndex === 0)
            const match = this.enemies.find(en => en.word.startsWith(key) && en.typedIndex === 0);
            
            if (match) {
                this.targetEnemy = match;
                match.isLocked = true;
                this.processCorrectHit(match);
                handled = true;
            } else {
                // Typo on no target
                this.missedKeystrokes++;
                // Optional: small error sound?
            }
        }
    }

    processCorrectHit(enemy) {
        AudioSys.playKeystroke();
        
        // Shoot bullet
        this.createBullet(this.player.x, this.player.y - 40, enemy.x + (enemy.typedIndex * 12), enemy.y);
        
        enemy.typedIndex++;
        
        if (enemy.typedIndex === enemy.word.length) {
            this.destroyEnemy(enemy);
        }
    }

    destroyEnemy(enemy) {
        this.score += 10 * this.combo * (enemy.type === 'ARMORED' ? 2 : 1);
        this.combo++;
        this.wordsTyped++;
        this.difficultyMultiplier += 0.05;
        
        AudioSys.playExplosion();
        this.createExplosion(enemy.x, enemy.y, enemy.type === 'ARMORED' ? '#ff8800' : '#00f3ff');
        this.shake = 5;
        
        this.enemies = this.enemies.filter(e => e !== enemy);
        if (this.targetEnemy === enemy) this.targetEnemy = null;
        
        this.updateHUD();
        this.animateCombo();
    }

    breakCombo() {
        this.combo = 0;
        this.targetEnemy = null;
        // CRITICAL FIX: Reset progress of ALL enemies to prevent partial locking bug
        this.enemies.forEach(e => {
            e.isLocked = false;
            e.typedIndex = 0; // Force reset
        });
        this.updateHUD();
    }

    createBullet(sx, sy, tx, ty) {
        AudioSys.playShoot();
        this.bullets.push(new Bullet(sx, sy, tx, ty));
    }

    createExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }
    
    createFloatingText(x, y, text, color) {
        // Simplified for this version
    }

    animateCombo() {
        const el = document.getElementById('comboDisplay');
        el.innerText = `COMBO x${this.combo}`;
        el.style.opacity = 1;
        el.style.transform = "scale(1.5)";
        setTimeout(() => {
            el.style.transform = "scale(1)";
            el.style.opacity = this.combo > 1 ? 1 : 0;
        }, 100);
    }

    updateHUD() {
        document.getElementById('scoreDisplay').innerText = this.score;
        document.getElementById('comboDisplay').innerText = `COMBO x${this.combo}`;
        
        const elapsedMin = (Date.now() - this.startTime) / 60000;
        const wpm = elapsedMin > 0 ? Math.floor((this.wordsTyped) / elapsedMin) : 0;
        document.getElementById('wpmDisplay').innerText = wpm;
    }

    gameOver() {
        this.state = 'GAMEOVER';
        const elapsedMin = (Date.now() - this.startTime) / 60000;
        const finalWpm = elapsedMin > 0 ? Math.floor((this.wordsTyped) / elapsedMin) : 0;
        const accuracy = this.totalKeystrokes > 0 
            ? Math.floor(((this.totalKeystrokes - this.missedKeystrokes) / this.totalKeystrokes) * 100) 
            : 0;

        document.getElementById('finalScore').innerText = this.score;
        document.getElementById('finalWpm').innerText = finalWpm;
        document.getElementById('finalAcc').innerText = accuracy + '%';
        document.getElementById('finalWords').innerText = this.wordsTyped;
        
        document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    loop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.ctx.fillStyle = 'rgba(5, 5, 16, 0.4)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.ctx.save();
        if (this.shake > 0) {
            const sx = (Math.random() - 0.5) * this.shake;
            const sy = (Math.random() - 0.5) * this.shake;
            this.ctx.translate(sx, sy);
            this.shake *= 0.9;
            if (this.shake < 0.5) this.shake = 0;
        }

        this.drawGrid();

        if (this.state === 'PLAYING') {
            this.player.update(dt);
            this.player.draw(this.ctx);

            this.enemies.forEach((enemy, index) => {
                enemy.update(dt);
                enemy.draw(this.ctx);
                
                if (enemy.y > this.height - 50) {
                    this.createExplosion(this.player.x, this.player.y, '#ff0000');
                    this.gameOver();
                }
            });

            this.bullets.forEach((b, i) => {
                b.update(dt);
                b.draw(this.ctx);
                if (b.life <= 0) this.bullets.splice(i, 1);
            });

            this.particles.forEach((p, i) => {
                p.update(dt);
                p.draw(this.ctx);
                if (p.life <= 0) this.particles.splice(i, 1);
            });
            
            if (this.targetEnemy && this.enemies.includes(this.targetEnemy)) {
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x, this.player.y - 20);
                this.ctx.lineTo(this.targetEnemy.x, this.targetEnemy.y);
                this.ctx.strokeStyle = 'rgba(0, 243, 255, 0.2)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([5, 5]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
        }

        this.ctx.restore();
        requestAnimationFrame((t) => this.loop(t));
    }

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 243, 255, 0.1)';
        this.ctx.lineWidth = 1;
        for (let x = 0; x <= this.width; x += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.height);
            this.ctx.stroke();
        }
        const offset = (Date.now() / 50) % 50;
        for (let y = offset; y <= this.height; y += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.width, y);
            this.ctx.stroke();
        }
    }
}

class Player {
    constructor(game) {
        this.game = game;
        this.x = game.width / 2;
        this.y = game.height - 80;
        this.width = 50;
        this.height = 50;
        this.tilt = 0;
    }

    update(dt) {
        this.y = this.game.height - 80 + Math.sin(Date.now() / 500) * 5;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.shadowBlur = 15;
        ctx.shadowColor = 'rgba(0, 243, 255, 0.5)';
        ctx.fillStyle = '#0a1a2a';
        ctx.beginPath();
        ctx.moveTo(0, -30);
        ctx.lineTo(20, 10);
        ctx.lineTo(30, 20);
        ctx.lineTo(-30, 20);
        ctx.lineTo(-20, 10);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#00f3ff';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#00f3ff';
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00f3ff';
        ctx.fillStyle = 'rgba(0, 243, 255, 0.8)';
        ctx.beginPath();
        ctx.moveTo(-10, 20);
        ctx.lineTo(0, 35 + Math.random() * 10);
        ctx.lineTo(10, 20);
        ctx.fill();
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, word, speed, type) {
        this.x = x;
        this.y = y;
        this.word = word;
        this.type = type;
        this.speed = speed;
        this.typedIndex = 0;
        this.isLocked = false;
        this.wobbleOffset = Math.random() * Math.PI * 2;
    }

    update(dt) {
        this.y += this.speed;
        this.wobbleOffset += dt * 2;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + (Math.sin(this.wobbleOffset) * 5), this.y);

        const color = this.isLocked ? '#ff0055' : (this.type === 'ARMORED' ? '#ffaa00' : '#ffffff');
        ctx.shadowBlur = this.isLocked ? 20 : 10;
        ctx.shadowColor = color;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';

        ctx.beginPath();
        if (this.type === 'ARMORED') {
            ctx.moveTo(0, 20);
            ctx.lineTo(15, -10);
            ctx.lineTo(25, 0); 
            ctx.lineTo(15, 10);
            ctx.lineTo(-15, 10);
            ctx.lineTo(-25, 0);
            ctx.lineTo(-15, -10);
        } else {
            ctx.moveTo(0, 25);
            ctx.lineTo(10, -5);
            ctx.lineTo(20, -10);
            ctx.lineTo(0, -5); 
            ctx.lineTo(-20, -10);
            ctx.lineTo(-10, -5);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.font = 'bold 20px "Roboto Mono"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const remainingWord = this.word.substring(this.typedIndex);
        const typedWord = this.word.substring(0, this.typedIndex);
        
        const totalWidth = ctx.measureText(this.word).width;
        const startX = -totalWidth / 2;

        ctx.fillStyle = 'rgba(0, 255, 102, 0.5)';
        ctx.fillText(typedWord, startX + ctx.measureText(typedWord).width/2, -30);

        ctx.fillStyle = this.isLocked ? '#ff0055' : '#fff';
        ctx.fillText(remainingWord, startX + ctx.measureText(typedWord).width + ctx.measureText(remainingWord).width/2, -30);
        
        if (this.isLocked) {
            ctx.beginPath();
            ctx.strokeStyle = '#ff0055';
            ctx.lineWidth = 1;
            ctx.arc(0, 5, 30, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(-5, 40);
            ctx.lineTo(5, 40);
            ctx.lineTo(0, 50);
            ctx.fillStyle = '#ff0055';
            ctx.fill();
        }

        ctx.restore();
    }
}

class Bullet {
    constructor(sx, sy, tx, ty) {
        this.x = sx;
        this.y = sy;
        this.tx = tx;
        this.ty = ty;
        this.speed = 1000; 
        const angle = Math.atan2(ty - sy, tx - sx);
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.life = 1.0;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        const dist = Math.hypot(this.x - this.tx, this.y - this.ty);
        if (dist < 50) this.life = 0; 
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        ctx.fillStyle = '#00f3ff';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00f3ff';
        ctx.beginPath();
        ctx.rect(-10, -2, 20, 4);
        ctx.fill();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 100 + 50;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const game = new Game();

</script>
</body>
</html>
